
zephyr.elf:     file format elf32-littleriscv


Disassembly of section rom_start:

80000000 <__start>:
SECTION_FUNC(vectors, __start)
#if defined(CONFIG_RISCV_GP)
	/* Initialize global pointer */
	.option push
	.option norelax
	la gp, __global_pointer$
80000000:	00004197          	auipc	gp,0x4
80000004:	79018193          	addi	gp,gp,1936 # 80004790 <__global_pointer$>
#else
	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to _isr_wrapper.
	 */
	la t0, _isr_wrapper
80000008:	00000297          	auipc	t0,0x0
8000000c:	01828293          	addi	t0,t0,24 # 80000020 <_isr_wrapper>
#endif

	csrw mtvec, t0
80000010:	30529073          	csrw	mtvec,t0

	/* Jump to __reset */
	tail __reset
80000014:	a011                	j	80000018 <__reset>
	...

Disassembly of section reset:

80000018 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
80000018:	7d4000ef          	jal	ra,800007ec <__initialize>
	...

Disassembly of section exceptions:

80000020 <_isr_wrapper>:
	csrrw sp, mscratch, sp
1:
#endif

	/* Save caller-saved registers on current thread stack. */
	addi sp, sp, -__z_arch_esf_t_SIZEOF
80000020:	715d                	addi	sp,sp,-80
	DO_CALLER_SAVED(sr)		;
80000022:	c216                	sw	t0,4(sp)
80000024:	c41a                	sw	t1,8(sp)
80000026:	c61e                	sw	t2,12(sp)
80000028:	c872                	sw	t3,16(sp)
8000002a:	ca76                	sw	t4,20(sp)
8000002c:	cc7a                	sw	t5,24(sp)
8000002e:	ce7e                	sw	t6,28(sp)
80000030:	d02a                	sw	a0,32(sp)
80000032:	d22e                	sw	a1,36(sp)
80000034:	d432                	sw	a2,40(sp)
80000036:	d636                	sw	a3,44(sp)
80000038:	d83a                	sw	a4,48(sp)
8000003a:	da3e                	sw	a5,52(sp)
8000003c:	dc42                	sw	a6,56(sp)
8000003e:	de46                	sw	a7,60(sp)
80000040:	c006                	sw	ra,0(sp)

	/* Save s0 in the esf and load it with &_current_cpu. */
	sr s0, __z_arch_esf_t_s0_OFFSET(sp)
80000042:	c4a2                	sw	s0,72(sp)
	GET_CURRENT_CPU(s0, t0)
80000044:	00003417          	auipc	s0,0x3
80000048:	11440413          	addi	s0,s0,276 # 80003158 <_kernel>
	add t0, t0, tp, %tprel_add(is_user_mode)
	sb zero, %tprel_lo(is_user_mode)(t0)
#endif

	/* Save MEPC register */
	csrr t0, mepc
8000004c:	341022f3          	csrr	t0,mepc
	sr t0, __z_arch_esf_t_mepc_OFFSET(sp)
80000050:	c096                	sw	t0,64(sp)

	/* Save MSTATUS register */
	csrr t2, mstatus
80000052:	300023f3          	csrr	t2,mstatus
	sr t2, __z_arch_esf_t_mstatus_OFFSET(sp)
80000056:	c29e                	sw	t2,68(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
80000058:	0f4000ef          	jal	ra,8000014c <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	bnez a0, is_interrupt
8000005c:	ed15                	bnez	a0,80000098 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
8000005e:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
80000062:	800003b7          	lui	t2,0x80000
80000066:	13fd                	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
80000068:	0072f2b3          	and	t0,t0,t2

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	li t1, SOC_MCAUSE_ECALL_EXP
8000006c:	432d                	li	t1,11
	beq t0, t1, is_kernel_syscall
8000006e:	00628963          	beq	t0,t1,80000080 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	mv a0, sp
80000072:	850a                	mv	a0,sp
	la ra, no_reschedule
80000074:	00000097          	auipc	ra,0x0
80000078:	09208093          	addi	ra,ra,146 # 80000106 <z_riscv_thread_start>
	tail _Fault
8000007c:	4480106f          	j	800014c4 <_Fault>

80000080 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	lr t0, __z_arch_esf_t_mepc_OFFSET(sp)
80000080:	4286                	lw	t0,64(sp)
	addi t0, t0, 4
80000082:	0291                	addi	t0,t0,4
	sr t0, __z_arch_esf_t_mepc_OFFSET(sp)
80000084:	c096                	sw	t0,64(sp)
	li t1, MSTATUS_MPRV
	csrs mstatus, t1
#endif

	/* Determine what to do. Operation code is in t0. */
	lr t0, __z_arch_esf_t_t0_OFFSET(sp)
80000086:	4292                	lw	t0,4(sp)

	.if RV_ECALL_RUNTIME_EXCEPT != 0; .err; .endif
	beqz t0, do_fault
80000088:	00028463          	beqz	t0,80000090 <do_fault>
	j reschedule
skip_schedule:
#endif

	/* default fault code is K_ERR_KERNEL_OOPS */
	li a0, 3
8000008c:	450d                	li	a0,3
	j 1f
8000008e:	a011                	j	80000092 <do_fault+0x2>

80000090 <do_fault>:

do_fault:
	/* Handle RV_ECALL_RUNTIME_EXCEPT. Retrieve reason in a0, esf in A1. */
	lr a0, __z_arch_esf_t_a0_OFFSET(sp)
80000090:	5502                	lw	a0,32(sp)
1:	mv a1, sp
80000092:	858a                	mv	a1,sp
	tail z_riscv_fatal_error
80000094:	4280106f          	j	800014bc <z_riscv_fatal_error>

80000098 <is_interrupt>:
	csrs mstatus, t1
2:
#endif

	/* Increment _current_cpu->nested */
	lw t1, ___cpu_t_nested_OFFSET(s0)
80000098:	00042303          	lw	t1,0(s0)
	addi t2, t1, 1
8000009c:	00130393          	addi	t2,t1,1
	sw t2, ___cpu_t_nested_OFFSET(s0)
800000a0:	00742023          	sw	t2,0(s0)
	bnez t1, on_irq_stack
800000a4:	00031763          	bnez	t1,800000b2 <on_irq_stack>

	/* Switch to interrupt stack */
	mv t0, sp
800000a8:	828a                	mv	t0,sp
	lr sp, ___cpu_t_irq_stack_OFFSET(s0)
800000aa:	00442103          	lw	sp,4(s0)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
800000ae:	1141                	addi	sp,sp,-16
	sr t0, 0(sp)
800000b0:	c016                	sw	t0,0(sp)

800000b2 <on_irq_stack>:
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
800000b2:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
800000b6:	800002b7          	lui	t0,0x80000
800000ba:	12fd                	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
800000bc:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
800000c0:	07c000ef          	jal	ra,8000013c <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
800000c4:	00003297          	auipc	t0,0x3
800000c8:	81428293          	addi	t0,t0,-2028 # 800028d8 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
800000cc:	050e                	slli	a0,a0,0x3
	add t0, t0, a0
800000ce:	92aa                	add	t0,t0,a0

	/* Load argument in a0 register */
	lr a0, 0(t0)
800000d0:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	lr t1, RV_REGSIZE(t0)
800000d4:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1, 0
800000d8:	000300e7          	jalr	t1

800000dc <irq_done>:
    call sys_trace_isr_exit
#endif

irq_done:
	/* Decrement _current_cpu->nested */
	lw t2, ___cpu_t_nested_OFFSET(s0)
800000dc:	00042383          	lw	t2,0(s0)
	addi t2, t2, -1
800000e0:	13fd                	addi	t2,t2,-1
	sw t2, ___cpu_t_nested_OFFSET(s0)
800000e2:	00742023          	sw	t2,0(s0)
	bnez t2, no_reschedule
800000e6:	02039063          	bnez	t2,80000106 <z_riscv_thread_start>

	/* nested count is back to 0: Return to thread stack */
	lr sp, 0(sp)
800000ea:	4102                	lw	sp,0(sp)

#ifdef CONFIG_STACK_SENTINEL
	call z_check_stack_sentinel
800000ec:	549010ef          	jal	ra,80001e34 <z_check_stack_sentinel>

800000f0 <check_reschedule>:
#endif

check_reschedule:

	/* Get pointer to current thread on this CPU */
	lr a1, ___cpu_t_current_OFFSET(s0)
800000f0:	440c                	lw	a1,8(s0)
	/*
	 * Get next thread to schedule with z_get_next_switch_handle().
	 * We pass it a NULL as we didn't save the whole thread context yet.
	 * If no scheduling is necessary then NULL will be returned.
	 */
	addi sp, sp, -16
800000f2:	1141                	addi	sp,sp,-16
	sr a1, 0(sp)
800000f4:	c02e                	sw	a1,0(sp)
	mv a0, zero
800000f6:	00000513          	li	a0,0
	call z_get_next_switch_handle
800000fa:	362020ef          	jal	ra,8000245c <z_get_next_switch_handle>
	lr a1, 0(sp)
800000fe:	4582                	lw	a1,0(sp)
	addi sp, sp, 16
80000100:	0141                	addi	sp,sp,16
	beqz a0, no_reschedule
80000102:	c111                	beqz	a0,80000106 <z_riscv_thread_start>

80000104 <reschedule>:
	/*
	 * Perform context switch:
	 * a0 = new thread
	 * a1 = old thread
	 */
	call z_riscv_switch
80000104:	2f35                	jal	80000840 <z_riscv_switch>

80000106 <z_riscv_thread_start>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	lr t0, __z_arch_esf_t_mepc_OFFSET(sp)
80000106:	4286                	lw	t0,64(sp)
	csrw mepc, t0
80000108:	34129073          	csrw	mepc,t0

	/* Restore MSTATUS register */
	lr t2, __z_arch_esf_t_mstatus_OFFSET(sp)
8000010c:	4396                	lw	t2,68(sp)
	csrrw t0, mstatus, t2
8000010e:	300392f3          	csrrw	t0,mstatus,t2
	csrw mscratch, t0
1:
#endif

	/* Restore s0 (it is no longer ours) */
	lr s0, __z_arch_esf_t_s0_OFFSET(sp)
80000112:	4426                	lw	s0,72(sp)

	/* Restore caller-saved registers from thread stack */
	DO_CALLER_SAVED(lr)
80000114:	4292                	lw	t0,4(sp)
80000116:	4322                	lw	t1,8(sp)
80000118:	43b2                	lw	t2,12(sp)
8000011a:	4e42                	lw	t3,16(sp)
8000011c:	4ed2                	lw	t4,20(sp)
8000011e:	4f62                	lw	t5,24(sp)
80000120:	4ff2                	lw	t6,28(sp)
80000122:	5502                	lw	a0,32(sp)
80000124:	5592                	lw	a1,36(sp)
80000126:	5622                	lw	a2,40(sp)
80000128:	56b2                	lw	a3,44(sp)
8000012a:	5742                	lw	a4,48(sp)
8000012c:	57d2                	lw	a5,52(sp)
8000012e:	5862                	lw	a6,56(sp)
80000130:	58f2                	lw	a7,60(sp)
80000132:	4082                	lw	ra,0(sp)
#ifdef CONFIG_USERSPACE
	/* retrieve saved stack pointer */
	lr sp, __z_arch_esf_t_sp_OFFSET(sp)
#else
	/* remove esf from the stack */
	addi sp, sp, __z_arch_esf_t_SIZEOF
80000134:	6161                	addi	sp,sp,80
#endif

	mret
80000136:	30200073          	mret
	...

8000013c <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
8000013c:	4305                	li	t1,1
	sll t0, t1, a0
8000013e:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
80000142:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	ret
80000146:	8082                	ret
80000148:	0000                	unimp
	...

8000014c <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
8000014c:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
80000150:	80000337          	lui	t1,0x80000
	and t0, t0, t1
80000154:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
80000158:	4501                	li	a0,0
	beqz t0, not_interrupt
8000015a:	00028363          	beqz	t0,80000160 <not_interrupt>
	addi a0, a0, 1
8000015e:	0505                	addi	a0,a0,1

80000160 <not_interrupt>:

not_interrupt:
	/* return */
	ret
80000160:	8082                	ret

Disassembly of section text:

80000164 <__udivdi3>:
80000164:	88aa                	mv	a7,a0
80000166:	832e                	mv	t1,a1
80000168:	8732                	mv	a4,a2
8000016a:	882a                	mv	a6,a0
8000016c:	87ae                	mv	a5,a1
8000016e:	20069663          	bnez	a3,8000037a <__udivdi3+0x216>
80000172:	800035b7          	lui	a1,0x80003
80000176:	ae058593          	addi	a1,a1,-1312 # 80002ae0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002ae1>
8000017a:	0cc37163          	bgeu	t1,a2,8000023c <__udivdi3+0xd8>
8000017e:	66c1                	lui	a3,0x10
80000180:	0ad67763          	bgeu	a2,a3,8000022e <__udivdi3+0xca>
80000184:	10063693          	sltiu	a3,a2,256
80000188:	0016c693          	xori	a3,a3,1
8000018c:	068e                	slli	a3,a3,0x3
8000018e:	00d65533          	srl	a0,a2,a3
80000192:	95aa                	add	a1,a1,a0
80000194:	0005c583          	lbu	a1,0(a1)
80000198:	02000513          	li	a0,32
8000019c:	96ae                	add	a3,a3,a1
8000019e:	40d505b3          	sub	a1,a0,a3
800001a2:	00d50b63          	beq	a0,a3,800001b8 <__udivdi3+0x54>
800001a6:	00b317b3          	sll	a5,t1,a1
800001aa:	00d8d6b3          	srl	a3,a7,a3
800001ae:	00b61733          	sll	a4,a2,a1
800001b2:	8fd5                	or	a5,a5,a3
800001b4:	00b89833          	sll	a6,a7,a1
800001b8:	01075593          	srli	a1,a4,0x10
800001bc:	02b7d333          	divu	t1,a5,a1
800001c0:	01071613          	slli	a2,a4,0x10
800001c4:	8241                	srli	a2,a2,0x10
800001c6:	02b7f7b3          	remu	a5,a5,a1
800001ca:	851a                	mv	a0,t1
800001cc:	026608b3          	mul	a7,a2,t1
800001d0:	01079693          	slli	a3,a5,0x10
800001d4:	01085793          	srli	a5,a6,0x10
800001d8:	8fd5                	or	a5,a5,a3
800001da:	0117fc63          	bgeu	a5,a7,800001f2 <__udivdi3+0x8e>
800001de:	97ba                	add	a5,a5,a4
800001e0:	fff30513          	addi	a0,t1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
800001e4:	00e7e763          	bltu	a5,a4,800001f2 <__udivdi3+0x8e>
800001e8:	0117f563          	bgeu	a5,a7,800001f2 <__udivdi3+0x8e>
800001ec:	ffe30513          	addi	a0,t1,-2
800001f0:	97ba                	add	a5,a5,a4
800001f2:	411787b3          	sub	a5,a5,a7
800001f6:	02b7d8b3          	divu	a7,a5,a1
800001fa:	0842                	slli	a6,a6,0x10
800001fc:	01085813          	srli	a6,a6,0x10
80000200:	02b7f7b3          	remu	a5,a5,a1
80000204:	031606b3          	mul	a3,a2,a7
80000208:	07c2                	slli	a5,a5,0x10
8000020a:	00f86833          	or	a6,a6,a5
8000020e:	87c6                	mv	a5,a7
80000210:	00d87b63          	bgeu	a6,a3,80000226 <__udivdi3+0xc2>
80000214:	983a                	add	a6,a6,a4
80000216:	fff88793          	addi	a5,a7,-1
8000021a:	00e86663          	bltu	a6,a4,80000226 <__udivdi3+0xc2>
8000021e:	00d87463          	bgeu	a6,a3,80000226 <__udivdi3+0xc2>
80000222:	ffe88793          	addi	a5,a7,-2
80000226:	0542                	slli	a0,a0,0x10
80000228:	8d5d                	or	a0,a0,a5
8000022a:	4581                	li	a1,0
8000022c:	8082                	ret
8000022e:	01000537          	lui	a0,0x1000
80000232:	46c1                	li	a3,16
80000234:	f4a66de3          	bltu	a2,a0,8000018e <__udivdi3+0x2a>
80000238:	46e1                	li	a3,24
8000023a:	bf91                	j	8000018e <__udivdi3+0x2a>
8000023c:	4681                	li	a3,0
8000023e:	ca09                	beqz	a2,80000250 <__udivdi3+0xec>
80000240:	67c1                	lui	a5,0x10
80000242:	08f67f63          	bgeu	a2,a5,800002e0 <__udivdi3+0x17c>
80000246:	10063693          	sltiu	a3,a2,256
8000024a:	0016c693          	xori	a3,a3,1
8000024e:	068e                	slli	a3,a3,0x3
80000250:	00d657b3          	srl	a5,a2,a3
80000254:	95be                	add	a1,a1,a5
80000256:	0005c783          	lbu	a5,0(a1)
8000025a:	97b6                	add	a5,a5,a3
8000025c:	02000693          	li	a3,32
80000260:	40f685b3          	sub	a1,a3,a5
80000264:	08f69563          	bne	a3,a5,800002ee <__udivdi3+0x18a>
80000268:	40c307b3          	sub	a5,t1,a2
8000026c:	4585                	li	a1,1
8000026e:	01075893          	srli	a7,a4,0x10
80000272:	0317de33          	divu	t3,a5,a7
80000276:	01071613          	slli	a2,a4,0x10
8000027a:	8241                	srli	a2,a2,0x10
8000027c:	01085693          	srli	a3,a6,0x10
80000280:	0317f7b3          	remu	a5,a5,a7
80000284:	8572                	mv	a0,t3
80000286:	03c60333          	mul	t1,a2,t3
8000028a:	07c2                	slli	a5,a5,0x10
8000028c:	8fd5                	or	a5,a5,a3
8000028e:	0067fc63          	bgeu	a5,t1,800002a6 <__udivdi3+0x142>
80000292:	97ba                	add	a5,a5,a4
80000294:	fffe0513          	addi	a0,t3,-1
80000298:	00e7e763          	bltu	a5,a4,800002a6 <__udivdi3+0x142>
8000029c:	0067f563          	bgeu	a5,t1,800002a6 <__udivdi3+0x142>
800002a0:	ffee0513          	addi	a0,t3,-2
800002a4:	97ba                	add	a5,a5,a4
800002a6:	406787b3          	sub	a5,a5,t1
800002aa:	0317d333          	divu	t1,a5,a7
800002ae:	0842                	slli	a6,a6,0x10
800002b0:	01085813          	srli	a6,a6,0x10
800002b4:	0317f7b3          	remu	a5,a5,a7
800002b8:	026606b3          	mul	a3,a2,t1
800002bc:	07c2                	slli	a5,a5,0x10
800002be:	00f86833          	or	a6,a6,a5
800002c2:	879a                	mv	a5,t1
800002c4:	00d87b63          	bgeu	a6,a3,800002da <__udivdi3+0x176>
800002c8:	983a                	add	a6,a6,a4
800002ca:	fff30793          	addi	a5,t1,-1
800002ce:	00e86663          	bltu	a6,a4,800002da <__udivdi3+0x176>
800002d2:	00d87463          	bgeu	a6,a3,800002da <__udivdi3+0x176>
800002d6:	ffe30793          	addi	a5,t1,-2
800002da:	0542                	slli	a0,a0,0x10
800002dc:	8d5d                	or	a0,a0,a5
800002de:	8082                	ret
800002e0:	010007b7          	lui	a5,0x1000
800002e4:	46c1                	li	a3,16
800002e6:	f6f665e3          	bltu	a2,a5,80000250 <__udivdi3+0xec>
800002ea:	46e1                	li	a3,24
800002ec:	b795                	j	80000250 <__udivdi3+0xec>
800002ee:	00b61733          	sll	a4,a2,a1
800002f2:	00f356b3          	srl	a3,t1,a5
800002f6:	01075513          	srli	a0,a4,0x10
800002fa:	00b31333          	sll	t1,t1,a1
800002fe:	00f8d7b3          	srl	a5,a7,a5
80000302:	0067e7b3          	or	a5,a5,t1
80000306:	02a6d333          	divu	t1,a3,a0
8000030a:	01071613          	slli	a2,a4,0x10
8000030e:	8241                	srli	a2,a2,0x10
80000310:	00b89833          	sll	a6,a7,a1
80000314:	02a6f6b3          	remu	a3,a3,a0
80000318:	026608b3          	mul	a7,a2,t1
8000031c:	01069593          	slli	a1,a3,0x10
80000320:	0107d693          	srli	a3,a5,0x10
80000324:	8ecd                	or	a3,a3,a1
80000326:	859a                	mv	a1,t1
80000328:	0116fc63          	bgeu	a3,a7,80000340 <__udivdi3+0x1dc>
8000032c:	96ba                	add	a3,a3,a4
8000032e:	fff30593          	addi	a1,t1,-1
80000332:	00e6e763          	bltu	a3,a4,80000340 <__udivdi3+0x1dc>
80000336:	0116f563          	bgeu	a3,a7,80000340 <__udivdi3+0x1dc>
8000033a:	ffe30593          	addi	a1,t1,-2
8000033e:	96ba                	add	a3,a3,a4
80000340:	411686b3          	sub	a3,a3,a7
80000344:	02a6d8b3          	divu	a7,a3,a0
80000348:	07c2                	slli	a5,a5,0x10
8000034a:	83c1                	srli	a5,a5,0x10
8000034c:	02a6f6b3          	remu	a3,a3,a0
80000350:	03160633          	mul	a2,a2,a7
80000354:	06c2                	slli	a3,a3,0x10
80000356:	8fd5                	or	a5,a5,a3
80000358:	86c6                	mv	a3,a7
8000035a:	00c7fc63          	bgeu	a5,a2,80000372 <__udivdi3+0x20e>
8000035e:	97ba                	add	a5,a5,a4
80000360:	fff88693          	addi	a3,a7,-1
80000364:	00e7e763          	bltu	a5,a4,80000372 <__udivdi3+0x20e>
80000368:	00c7f563          	bgeu	a5,a2,80000372 <__udivdi3+0x20e>
8000036c:	ffe88693          	addi	a3,a7,-2
80000370:	97ba                	add	a5,a5,a4
80000372:	05c2                	slli	a1,a1,0x10
80000374:	8f91                	sub	a5,a5,a2
80000376:	8dd5                	or	a1,a1,a3
80000378:	bddd                	j	8000026e <__udivdi3+0x10a>
8000037a:	14d5e163          	bltu	a1,a3,800004bc <__udivdi3+0x358>
8000037e:	67c1                	lui	a5,0x10
80000380:	02f6ff63          	bgeu	a3,a5,800003be <__udivdi3+0x25a>
80000384:	1006b713          	sltiu	a4,a3,256
80000388:	00174713          	xori	a4,a4,1
8000038c:	070e                	slli	a4,a4,0x3
8000038e:	800037b7          	lui	a5,0x80003
80000392:	00e6d5b3          	srl	a1,a3,a4
80000396:	ae078793          	addi	a5,a5,-1312 # 80002ae0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002ae1>
8000039a:	97ae                	add	a5,a5,a1
8000039c:	0007c783          	lbu	a5,0(a5)
800003a0:	97ba                	add	a5,a5,a4
800003a2:	02000713          	li	a4,32
800003a6:	40f705b3          	sub	a1,a4,a5
800003aa:	02f71163          	bne	a4,a5,800003cc <__udivdi3+0x268>
800003ae:	4505                	li	a0,1
800003b0:	e666eee3          	bltu	a3,t1,8000022c <__udivdi3+0xc8>
800003b4:	00c8b533          	sltu	a0,a7,a2
800003b8:	00154513          	xori	a0,a0,1
800003bc:	8082                	ret
800003be:	010007b7          	lui	a5,0x1000
800003c2:	4741                	li	a4,16
800003c4:	fcf6e5e3          	bltu	a3,a5,8000038e <__udivdi3+0x22a>
800003c8:	4761                	li	a4,24
800003ca:	b7d1                	j	8000038e <__udivdi3+0x22a>
800003cc:	00f65733          	srl	a4,a2,a5
800003d0:	00b696b3          	sll	a3,a3,a1
800003d4:	8ed9                	or	a3,a3,a4
800003d6:	00f35733          	srl	a4,t1,a5
800003da:	00b31333          	sll	t1,t1,a1
800003de:	00f8d7b3          	srl	a5,a7,a5
800003e2:	0067e7b3          	or	a5,a5,t1
800003e6:	0106d313          	srli	t1,a3,0x10
800003ea:	02675eb3          	divu	t4,a4,t1
800003ee:	01069813          	slli	a6,a3,0x10
800003f2:	01085813          	srli	a6,a6,0x10
800003f6:	00b61633          	sll	a2,a2,a1
800003fa:	02677733          	remu	a4,a4,t1
800003fe:	03d80e33          	mul	t3,a6,t4
80000402:	01071513          	slli	a0,a4,0x10
80000406:	0107d713          	srli	a4,a5,0x10
8000040a:	8f49                	or	a4,a4,a0
8000040c:	8576                	mv	a0,t4
8000040e:	01c77c63          	bgeu	a4,t3,80000426 <__udivdi3+0x2c2>
80000412:	9736                	add	a4,a4,a3
80000414:	fffe8513          	addi	a0,t4,-1
80000418:	00d76763          	bltu	a4,a3,80000426 <__udivdi3+0x2c2>
8000041c:	01c77563          	bgeu	a4,t3,80000426 <__udivdi3+0x2c2>
80000420:	ffee8513          	addi	a0,t4,-2
80000424:	9736                	add	a4,a4,a3
80000426:	41c70733          	sub	a4,a4,t3
8000042a:	02675e33          	divu	t3,a4,t1
8000042e:	07c2                	slli	a5,a5,0x10
80000430:	83c1                	srli	a5,a5,0x10
80000432:	02677733          	remu	a4,a4,t1
80000436:	03c80833          	mul	a6,a6,t3
8000043a:	0742                	slli	a4,a4,0x10
8000043c:	8fd9                	or	a5,a5,a4
8000043e:	8772                	mv	a4,t3
80000440:	0107fc63          	bgeu	a5,a6,80000458 <__udivdi3+0x2f4>
80000444:	97b6                	add	a5,a5,a3
80000446:	fffe0713          	addi	a4,t3,-1
8000044a:	00d7e763          	bltu	a5,a3,80000458 <__udivdi3+0x2f4>
8000044e:	0107f563          	bgeu	a5,a6,80000458 <__udivdi3+0x2f4>
80000452:	ffee0713          	addi	a4,t3,-2
80000456:	97b6                	add	a5,a5,a3
80000458:	0542                	slli	a0,a0,0x10
8000045a:	6e41                	lui	t3,0x10
8000045c:	8d59                	or	a0,a0,a4
8000045e:	fffe0693          	addi	a3,t3,-1 # ffff <__rom_region_size+0xcfff>
80000462:	00d57733          	and	a4,a0,a3
80000466:	410787b3          	sub	a5,a5,a6
8000046a:	8ef1                	and	a3,a3,a2
8000046c:	01055813          	srli	a6,a0,0x10
80000470:	8241                	srli	a2,a2,0x10
80000472:	02d70333          	mul	t1,a4,a3
80000476:	02d806b3          	mul	a3,a6,a3
8000047a:	02c70733          	mul	a4,a4,a2
8000047e:	02c80833          	mul	a6,a6,a2
80000482:	00d70633          	add	a2,a4,a3
80000486:	01035713          	srli	a4,t1,0x10
8000048a:	9732                	add	a4,a4,a2
8000048c:	00d77363          	bgeu	a4,a3,80000492 <__udivdi3+0x32e>
80000490:	9872                	add	a6,a6,t3
80000492:	01075693          	srli	a3,a4,0x10
80000496:	96c2                	add	a3,a3,a6
80000498:	02d7e063          	bltu	a5,a3,800004b8 <__udivdi3+0x354>
8000049c:	d8d797e3          	bne	a5,a3,8000022a <__udivdi3+0xc6>
800004a0:	67c1                	lui	a5,0x10
800004a2:	17fd                	addi	a5,a5,-1 # ffff <__rom_region_size+0xcfff>
800004a4:	8f7d                	and	a4,a4,a5
800004a6:	0742                	slli	a4,a4,0x10
800004a8:	00f37333          	and	t1,t1,a5
800004ac:	00b898b3          	sll	a7,a7,a1
800004b0:	971a                	add	a4,a4,t1
800004b2:	4581                	li	a1,0
800004b4:	d6e8fce3          	bgeu	a7,a4,8000022c <__udivdi3+0xc8>
800004b8:	157d                	addi	a0,a0,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x67697f>
800004ba:	bb85                	j	8000022a <__udivdi3+0xc6>
800004bc:	4581                	li	a1,0
800004be:	4501                	li	a0,0
800004c0:	8082                	ret

800004c2 <__umoddi3>:
800004c2:	8832                	mv	a6,a2
800004c4:	87aa                	mv	a5,a0
800004c6:	872e                	mv	a4,a1
800004c8:	1a069363          	bnez	a3,8000066e <__umoddi3+0x1ac>
800004cc:	800038b7          	lui	a7,0x80003
800004d0:	ae088893          	addi	a7,a7,-1312 # 80002ae0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002ae1>
800004d4:	0ac5f663          	bgeu	a1,a2,80000580 <__umoddi3+0xbe>
800004d8:	66c1                	lui	a3,0x10
800004da:	08d67c63          	bgeu	a2,a3,80000572 <__umoddi3+0xb0>
800004de:	10063693          	sltiu	a3,a2,256
800004e2:	0016c693          	xori	a3,a3,1
800004e6:	068e                	slli	a3,a3,0x3
800004e8:	00d65333          	srl	t1,a2,a3
800004ec:	989a                	add	a7,a7,t1
800004ee:	0008c883          	lbu	a7,0(a7)
800004f2:	02000313          	li	t1,32
800004f6:	96c6                	add	a3,a3,a7
800004f8:	40d308b3          	sub	a7,t1,a3
800004fc:	00d30b63          	beq	t1,a3,80000512 <__umoddi3+0x50>
80000500:	01159733          	sll	a4,a1,a7
80000504:	00d556b3          	srl	a3,a0,a3
80000508:	01161833          	sll	a6,a2,a7
8000050c:	8f55                	or	a4,a4,a3
8000050e:	011517b3          	sll	a5,a0,a7
80000512:	01085613          	srli	a2,a6,0x10
80000516:	02c756b3          	divu	a3,a4,a2
8000051a:	01081513          	slli	a0,a6,0x10
8000051e:	8141                	srli	a0,a0,0x10
80000520:	02c77733          	remu	a4,a4,a2
80000524:	02a686b3          	mul	a3,a3,a0
80000528:	01071593          	slli	a1,a4,0x10
8000052c:	0107d713          	srli	a4,a5,0x10
80000530:	8f4d                	or	a4,a4,a1
80000532:	00d77863          	bgeu	a4,a3,80000542 <__umoddi3+0x80>
80000536:	9742                	add	a4,a4,a6
80000538:	01076563          	bltu	a4,a6,80000542 <__umoddi3+0x80>
8000053c:	00d77363          	bgeu	a4,a3,80000542 <__umoddi3+0x80>
80000540:	9742                	add	a4,a4,a6
80000542:	8f15                	sub	a4,a4,a3
80000544:	02c756b3          	divu	a3,a4,a2
80000548:	02c77733          	remu	a4,a4,a2
8000054c:	02a686b3          	mul	a3,a3,a0
80000550:	07c2                	slli	a5,a5,0x10
80000552:	0742                	slli	a4,a4,0x10
80000554:	83c1                	srli	a5,a5,0x10
80000556:	8fd9                	or	a5,a5,a4
80000558:	00d7f863          	bgeu	a5,a3,80000568 <__umoddi3+0xa6>
8000055c:	97c2                	add	a5,a5,a6
8000055e:	0107e563          	bltu	a5,a6,80000568 <__umoddi3+0xa6>
80000562:	00d7f363          	bgeu	a5,a3,80000568 <__umoddi3+0xa6>
80000566:	97c2                	add	a5,a5,a6
80000568:	8f95                	sub	a5,a5,a3
8000056a:	0117d533          	srl	a0,a5,a7
8000056e:	4581                	li	a1,0
80000570:	8082                	ret
80000572:	01000337          	lui	t1,0x1000
80000576:	46c1                	li	a3,16
80000578:	f66668e3          	bltu	a2,t1,800004e8 <__umoddi3+0x26>
8000057c:	46e1                	li	a3,24
8000057e:	b7ad                	j	800004e8 <__umoddi3+0x26>
80000580:	4681                	li	a3,0
80000582:	ca09                	beqz	a2,80000594 <__umoddi3+0xd2>
80000584:	6741                	lui	a4,0x10
80000586:	06e67463          	bgeu	a2,a4,800005ee <__umoddi3+0x12c>
8000058a:	10063693          	sltiu	a3,a2,256
8000058e:	0016c693          	xori	a3,a3,1
80000592:	068e                	slli	a3,a3,0x3
80000594:	00d65733          	srl	a4,a2,a3
80000598:	98ba                	add	a7,a7,a4
8000059a:	0008c703          	lbu	a4,0(a7)
8000059e:	9736                	add	a4,a4,a3
800005a0:	02000693          	li	a3,32
800005a4:	40e688b3          	sub	a7,a3,a4
800005a8:	04e69a63          	bne	a3,a4,800005fc <__umoddi3+0x13a>
800005ac:	40c58733          	sub	a4,a1,a2
800005b0:	01085593          	srli	a1,a6,0x10
800005b4:	02b75633          	divu	a2,a4,a1
800005b8:	01081513          	slli	a0,a6,0x10
800005bc:	8141                	srli	a0,a0,0x10
800005be:	0107d693          	srli	a3,a5,0x10
800005c2:	02b77733          	remu	a4,a4,a1
800005c6:	02a60633          	mul	a2,a2,a0
800005ca:	0742                	slli	a4,a4,0x10
800005cc:	8f55                	or	a4,a4,a3
800005ce:	00c77863          	bgeu	a4,a2,800005de <__umoddi3+0x11c>
800005d2:	9742                	add	a4,a4,a6
800005d4:	01076563          	bltu	a4,a6,800005de <__umoddi3+0x11c>
800005d8:	00c77363          	bgeu	a4,a2,800005de <__umoddi3+0x11c>
800005dc:	9742                	add	a4,a4,a6
800005de:	8f11                	sub	a4,a4,a2
800005e0:	02b756b3          	divu	a3,a4,a1
800005e4:	02b77733          	remu	a4,a4,a1
800005e8:	02a686b3          	mul	a3,a3,a0
800005ec:	b795                	j	80000550 <__umoddi3+0x8e>
800005ee:	01000737          	lui	a4,0x1000
800005f2:	46c1                	li	a3,16
800005f4:	fae660e3          	bltu	a2,a4,80000594 <__umoddi3+0xd2>
800005f8:	46e1                	li	a3,24
800005fa:	bf69                	j	80000594 <__umoddi3+0xd2>
800005fc:	01161833          	sll	a6,a2,a7
80000600:	00e5d6b3          	srl	a3,a1,a4
80000604:	011517b3          	sll	a5,a0,a7
80000608:	011595b3          	sll	a1,a1,a7
8000060c:	00e55733          	srl	a4,a0,a4
80000610:	01085513          	srli	a0,a6,0x10
80000614:	8f4d                	or	a4,a4,a1
80000616:	02a6d5b3          	divu	a1,a3,a0
8000061a:	01081313          	slli	t1,a6,0x10
8000061e:	01035313          	srli	t1,t1,0x10
80000622:	02a6f6b3          	remu	a3,a3,a0
80000626:	026585b3          	mul	a1,a1,t1
8000062a:	01069613          	slli	a2,a3,0x10
8000062e:	01075693          	srli	a3,a4,0x10
80000632:	8ed1                	or	a3,a3,a2
80000634:	00b6f863          	bgeu	a3,a1,80000644 <__umoddi3+0x182>
80000638:	96c2                	add	a3,a3,a6
8000063a:	0106e563          	bltu	a3,a6,80000644 <__umoddi3+0x182>
8000063e:	00b6f363          	bgeu	a3,a1,80000644 <__umoddi3+0x182>
80000642:	96c2                	add	a3,a3,a6
80000644:	8e8d                	sub	a3,a3,a1
80000646:	02a6d633          	divu	a2,a3,a0
8000064a:	0742                	slli	a4,a4,0x10
8000064c:	8341                	srli	a4,a4,0x10
8000064e:	02a6f6b3          	remu	a3,a3,a0
80000652:	02660633          	mul	a2,a2,t1
80000656:	06c2                	slli	a3,a3,0x10
80000658:	8f55                	or	a4,a4,a3
8000065a:	00c77863          	bgeu	a4,a2,8000066a <__umoddi3+0x1a8>
8000065e:	9742                	add	a4,a4,a6
80000660:	01076563          	bltu	a4,a6,8000066a <__umoddi3+0x1a8>
80000664:	00c77363          	bgeu	a4,a2,8000066a <__umoddi3+0x1a8>
80000668:	9742                	add	a4,a4,a6
8000066a:	8f11                	sub	a4,a4,a2
8000066c:	b791                	j	800005b0 <__umoddi3+0xee>
8000066e:	16d5ed63          	bltu	a1,a3,800007e8 <__umoddi3+0x326>
80000672:	6841                	lui	a6,0x10
80000674:	0506f763          	bgeu	a3,a6,800006c2 <__umoddi3+0x200>
80000678:	1006b813          	sltiu	a6,a3,256
8000067c:	00184813          	xori	a6,a6,1
80000680:	080e                	slli	a6,a6,0x3
80000682:	800038b7          	lui	a7,0x80003
80000686:	0106d333          	srl	t1,a3,a6
8000068a:	ae088893          	addi	a7,a7,-1312 # 80002ae0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002ae1>
8000068e:	989a                	add	a7,a7,t1
80000690:	0008c883          	lbu	a7,0(a7)
80000694:	02000313          	li	t1,32
80000698:	98c2                	add	a7,a7,a6
8000069a:	41130833          	sub	a6,t1,a7
8000069e:	03131963          	bne	t1,a7,800006d0 <__umoddi3+0x20e>
800006a2:	00b6e463          	bltu	a3,a1,800006aa <__umoddi3+0x1e8>
800006a6:	00c56b63          	bltu	a0,a2,800006bc <__umoddi3+0x1fa>
800006aa:	40c50633          	sub	a2,a0,a2
800006ae:	40d586b3          	sub	a3,a1,a3
800006b2:	00c53733          	sltu	a4,a0,a2
800006b6:	87b2                	mv	a5,a2
800006b8:	40e68733          	sub	a4,a3,a4
800006bc:	853e                	mv	a0,a5
800006be:	85ba                	mv	a1,a4
800006c0:	8082                	ret
800006c2:	010008b7          	lui	a7,0x1000
800006c6:	4841                	li	a6,16
800006c8:	fb16ede3          	bltu	a3,a7,80000682 <__umoddi3+0x1c0>
800006cc:	4861                	li	a6,24
800006ce:	bf55                	j	80000682 <__umoddi3+0x1c0>
800006d0:	011657b3          	srl	a5,a2,a7
800006d4:	010696b3          	sll	a3,a3,a6
800006d8:	8edd                	or	a3,a3,a5
800006da:	0115d733          	srl	a4,a1,a7
800006de:	0106de13          	srli	t3,a3,0x10
800006e2:	03c75f33          	divu	t5,a4,t3
800006e6:	01069313          	slli	t1,a3,0x10
800006ea:	01035313          	srli	t1,t1,0x10
800006ee:	010597b3          	sll	a5,a1,a6
800006f2:	011555b3          	srl	a1,a0,a7
800006f6:	8ddd                	or	a1,a1,a5
800006f8:	0105d793          	srli	a5,a1,0x10
800006fc:	01061633          	sll	a2,a2,a6
80000700:	01051533          	sll	a0,a0,a6
80000704:	03c77733          	remu	a4,a4,t3
80000708:	03e30eb3          	mul	t4,t1,t5
8000070c:	0742                	slli	a4,a4,0x10
8000070e:	8fd9                	or	a5,a5,a4
80000710:	877a                	mv	a4,t5
80000712:	01d7fc63          	bgeu	a5,t4,8000072a <__umoddi3+0x268>
80000716:	97b6                	add	a5,a5,a3
80000718:	ffff0713          	addi	a4,t5,-1
8000071c:	00d7e763          	bltu	a5,a3,8000072a <__umoddi3+0x268>
80000720:	01d7f563          	bgeu	a5,t4,8000072a <__umoddi3+0x268>
80000724:	ffef0713          	addi	a4,t5,-2
80000728:	97b6                	add	a5,a5,a3
8000072a:	41d787b3          	sub	a5,a5,t4
8000072e:	03c7deb3          	divu	t4,a5,t3
80000732:	05c2                	slli	a1,a1,0x10
80000734:	81c1                	srli	a1,a1,0x10
80000736:	03c7f7b3          	remu	a5,a5,t3
8000073a:	8e76                	mv	t3,t4
8000073c:	03d30333          	mul	t1,t1,t4
80000740:	07c2                	slli	a5,a5,0x10
80000742:	8ddd                	or	a1,a1,a5
80000744:	0065fc63          	bgeu	a1,t1,8000075c <__umoddi3+0x29a>
80000748:	95b6                	add	a1,a1,a3
8000074a:	fffe8e13          	addi	t3,t4,-1
8000074e:	00d5e763          	bltu	a1,a3,8000075c <__umoddi3+0x29a>
80000752:	0065f563          	bgeu	a1,t1,8000075c <__umoddi3+0x29a>
80000756:	ffee8e13          	addi	t3,t4,-2
8000075a:	95b6                	add	a1,a1,a3
8000075c:	01071793          	slli	a5,a4,0x10
80000760:	6f41                	lui	t5,0x10
80000762:	01c7e7b3          	or	a5,a5,t3
80000766:	406585b3          	sub	a1,a1,t1
8000076a:	ffff0313          	addi	t1,t5,-1 # ffff <__rom_region_size+0xcfff>
8000076e:	0067f733          	and	a4,a5,t1
80000772:	01065e13          	srli	t3,a2,0x10
80000776:	83c1                	srli	a5,a5,0x10
80000778:	00667333          	and	t1,a2,t1
8000077c:	02670eb3          	mul	t4,a4,t1
80000780:	02678333          	mul	t1,a5,t1
80000784:	03c70733          	mul	a4,a4,t3
80000788:	03c787b3          	mul	a5,a5,t3
8000078c:	00670e33          	add	t3,a4,t1
80000790:	010ed713          	srli	a4,t4,0x10
80000794:	9772                	add	a4,a4,t3
80000796:	00677363          	bgeu	a4,t1,8000079c <__umoddi3+0x2da>
8000079a:	97fa                	add	a5,a5,t5
8000079c:	01075313          	srli	t1,a4,0x10
800007a0:	979a                	add	a5,a5,t1
800007a2:	6341                	lui	t1,0x10
800007a4:	137d                	addi	t1,t1,-1 # ffff <__rom_region_size+0xcfff>
800007a6:	00677733          	and	a4,a4,t1
800007aa:	0742                	slli	a4,a4,0x10
800007ac:	006efeb3          	and	t4,t4,t1
800007b0:	9776                	add	a4,a4,t4
800007b2:	00f5e663          	bltu	a1,a5,800007be <__umoddi3+0x2fc>
800007b6:	00f59b63          	bne	a1,a5,800007cc <__umoddi3+0x30a>
800007ba:	00e57963          	bgeu	a0,a4,800007cc <__umoddi3+0x30a>
800007be:	40c70633          	sub	a2,a4,a2
800007c2:	00c73333          	sltu	t1,a4,a2
800007c6:	969a                	add	a3,a3,t1
800007c8:	8732                	mv	a4,a2
800007ca:	8f95                	sub	a5,a5,a3
800007cc:	40e50733          	sub	a4,a0,a4
800007d0:	00e53533          	sltu	a0,a0,a4
800007d4:	8d9d                	sub	a1,a1,a5
800007d6:	8d89                	sub	a1,a1,a0
800007d8:	011598b3          	sll	a7,a1,a7
800007dc:	01075733          	srl	a4,a4,a6
800007e0:	00e8e533          	or	a0,a7,a4
800007e4:	0105d5b3          	srl	a1,a1,a6
800007e8:	8082                	ret
	...

800007ec <__initialize>:
/*
 * Remainder of asm-land initialization code before we can jump into
 * the C domain
 */
SECTION_FUNC(TEXT, __initialize)
	csrr a0, mhartid
800007ec:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_first_core
800007f0:	c519                	beqz	a0,800007fe <boot_first_core>

	li t0, CONFIG_MP_NUM_CPUS
800007f2:	4285                	li	t0,1
	blt a0, t0, boot_secondary_core
800007f4:	00554f63          	blt	a0,t0,80000812 <boot_secondary_core>

800007f8 <loop_unconfigured_cores>:

loop_unconfigured_cores:
	wfi
800007f8:	10500073          	wfi
	j loop_unconfigured_cores
800007fc:	bff5                	j	800007f8 <loop_unconfigured_cores>

800007fe <boot_first_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + __z_interrupt_stack_SIZEOF
	 */
	la sp, z_interrupt_stacks
800007fe:	00003117          	auipc	sp,0x3
80000802:	98210113          	addi	sp,sp,-1662 # 80003180 <z_interrupt_stacks>
	li t0, __z_interrupt_stack_SIZEOF
80000806:	6285                	lui	t0,0x1
80000808:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
8000080c:	9116                	add	sp,sp,t0

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
8000080e:	4d9000ef          	jal	ra,800014e6 <_PrepC>

80000812 <boot_secondary_core>:

boot_secondary_core:
	la t0, riscv_cpu_wake_flag
80000812:	00003297          	auipc	t0,0x3
80000816:	80228293          	addi	t0,t0,-2046 # 80003014 <riscv_cpu_wake_flag>
	lr t0, 0(t0)
8000081a:	0002a283          	lw	t0,0(t0)
	bne a0, t0, boot_secondary_core
8000081e:	fe551ae3          	bne	a0,t0,80000812 <boot_secondary_core>

	/* Set up stack */
	la t0, riscv_cpu_sp
80000822:	00002297          	auipc	t0,0x2
80000826:	7ee28293          	addi	t0,t0,2030 # 80003010 <riscv_cpu_sp>
	lr sp, 0(t0)
8000082a:	0002a103          	lw	sp,0(t0)

	la t0, riscv_cpu_wake_flag
8000082e:	00002297          	auipc	t0,0x2
80000832:	7e628293          	addi	t0,t0,2022 # 80003014 <riscv_cpu_wake_flag>
	sr zero, 0(t0)
80000836:	0002a023          	sw	zero,0(t0)
	j z_riscv_secondary_cpu_init
8000083a:	4bb0006f          	j	800014f4 <z_riscv_secondary_cpu_init>
	...

80000840 <z_riscv_switch>:

/* void z_riscv_switch(k_thread_t *switch_to, k_thread_t *switch_from) */
SECTION_FUNC(TEXT, z_riscv_switch)

	/* Save the old thread's callee-saved registers */
	DO_CALLEE_SAVED(sr, a1)
80000840:	0215aa23          	sw	ra,52(a1)
80000844:	dd80                	sw	s0,56(a1)
80000846:	ddc4                	sw	s1,60(a1)
80000848:	0525a023          	sw	s2,64(a1)
8000084c:	0535a223          	sw	s3,68(a1)
80000850:	0545a423          	sw	s4,72(a1)
80000854:	0555a623          	sw	s5,76(a1)
80000858:	0565a823          	sw	s6,80(a1)
8000085c:	0575aa23          	sw	s7,84(a1)
80000860:	0585ac23          	sw	s8,88(a1)
80000864:	0595ae23          	sw	s9,92(a1)
80000868:	07a5a023          	sw	s10,96(a1)
8000086c:	07b5a223          	sw	s11,100(a1)
	DO_FP_CALLEE_SAVED(fsr, a1)
skip_store_fp_callee_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save the old thread's stack pointer */
	sr sp, _thread_offset_to_sp(a1)
80000870:	0225a823          	sw	sp,48(a1)

	/* Set thread->switch_handle = thread to mark completion */
	sr a1, ___thread_t_switch_handle_OFFSET(a1)
80000874:	08b5a223          	sw	a1,132(a1)

	/* Get the new thread's stack pointer */
	lr sp, _thread_offset_to_sp(a0)
80000878:	03052103          	lw	sp,48(a0)

#if defined(CONFIG_THREAD_LOCAL_STORAGE)
	/* Get the new thread's tls pointer */
	lr tp, _thread_offset_to_tls(a0)
8000087c:	08c52203          	lw	tp,140(a0)
	call z_thread_mark_switched_in
	mv a0, s0
#endif

	/* Restore the new thread's callee-saved registers */
	DO_CALLEE_SAVED(lr, a0)
80000880:	03452083          	lw	ra,52(a0)
80000884:	5d00                	lw	s0,56(a0)
80000886:	5d44                	lw	s1,60(a0)
80000888:	04052903          	lw	s2,64(a0)
8000088c:	04452983          	lw	s3,68(a0)
80000890:	04852a03          	lw	s4,72(a0)
80000894:	04c52a83          	lw	s5,76(a0)
80000898:	05052b03          	lw	s6,80(a0)
8000089c:	05452b83          	lw	s7,84(a0)
800008a0:	05852c03          	lw	s8,88(a0)
800008a4:	05c52c83          	lw	s9,92(a0)
800008a8:	06052d03          	lw	s10,96(a0)
800008ac:	06452d83          	lw	s11,100(a0)
	csrc mstatus, t1
1:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Return to arch_switch() or _irq_wrapper() */
	ret
800008b0:	8082                	ret
	...

800008b4 <z_riscv_write_pmp_entries>:
 */

GTEXT(z_riscv_write_pmp_entries)
SECTION_FUNC(TEXT, z_riscv_write_pmp_entries)

	la t0, pmpaddr_store
800008b4:	00000297          	auipc	t0,0x0
800008b8:	01028293          	addi	t0,t0,16 # 800008c4 <pmpaddr_store>
	slli t1, a0, 4  /* 16-byte instruction blocks */
800008bc:	00451313          	slli	t1,a0,0x4
	add t0, t0, t1
800008c0:	929a                	add	t0,t0,t1
	jr t0
800008c2:	8282                	jr	t0

800008c4 <pmpaddr_store>:
	lr t0, (RV_REGSIZE * _index)(a3)
	li t1, _index + 1
	csrw (CSR_PMPADDR_BASE + _index), t0
	beq t1, a1, pmpaddr_done
	.set _index, _index + 1
	.endr
800008c4:	0006a283          	lw	t0,0(a3) # 10000 <__rom_region_size+0xd000>
800008c8:	00100313          	li	t1,1
800008cc:	3b029073          	csrw	pmpaddr0,t0
800008d0:	0eb30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
800008d4:	0046a283          	lw	t0,4(a3)
800008d8:	00200313          	li	t1,2
800008dc:	3b129073          	csrw	pmpaddr1,t0
800008e0:	0eb30263          	beq	t1,a1,800009c4 <pmpaddr_done>
800008e4:	0086a283          	lw	t0,8(a3)
800008e8:	00300313          	li	t1,3
800008ec:	3b229073          	csrw	pmpaddr2,t0
800008f0:	0cb30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
800008f4:	00c6a283          	lw	t0,12(a3)
800008f8:	00400313          	li	t1,4
800008fc:	3b329073          	csrw	pmpaddr3,t0
80000900:	0cb30263          	beq	t1,a1,800009c4 <pmpaddr_done>
80000904:	0106a283          	lw	t0,16(a3)
80000908:	00500313          	li	t1,5
8000090c:	3b429073          	csrw	pmpaddr4,t0
80000910:	0ab30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
80000914:	0146a283          	lw	t0,20(a3)
80000918:	00600313          	li	t1,6
8000091c:	3b529073          	csrw	pmpaddr5,t0
80000920:	0ab30263          	beq	t1,a1,800009c4 <pmpaddr_done>
80000924:	0186a283          	lw	t0,24(a3)
80000928:	00700313          	li	t1,7
8000092c:	3b629073          	csrw	pmpaddr6,t0
80000930:	08b30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
80000934:	01c6a283          	lw	t0,28(a3)
80000938:	00800313          	li	t1,8
8000093c:	3b729073          	csrw	pmpaddr7,t0
80000940:	08b30263          	beq	t1,a1,800009c4 <pmpaddr_done>
80000944:	0206a283          	lw	t0,32(a3)
80000948:	00900313          	li	t1,9
8000094c:	3b829073          	csrw	pmpaddr8,t0
80000950:	06b30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
80000954:	0246a283          	lw	t0,36(a3)
80000958:	00a00313          	li	t1,10
8000095c:	3b929073          	csrw	pmpaddr9,t0
80000960:	06b30263          	beq	t1,a1,800009c4 <pmpaddr_done>
80000964:	0286a283          	lw	t0,40(a3)
80000968:	00b00313          	li	t1,11
8000096c:	3ba29073          	csrw	pmpaddr10,t0
80000970:	04b30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
80000974:	02c6a283          	lw	t0,44(a3)
80000978:	00c00313          	li	t1,12
8000097c:	3bb29073          	csrw	pmpaddr11,t0
80000980:	04b30263          	beq	t1,a1,800009c4 <pmpaddr_done>
80000984:	0306a283          	lw	t0,48(a3)
80000988:	00d00313          	li	t1,13
8000098c:	3bc29073          	csrw	pmpaddr12,t0
80000990:	02b30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
80000994:	0346a283          	lw	t0,52(a3)
80000998:	00e00313          	li	t1,14
8000099c:	3bd29073          	csrw	pmpaddr13,t0
800009a0:	02b30263          	beq	t1,a1,800009c4 <pmpaddr_done>
800009a4:	0386a283          	lw	t0,56(a3)
800009a8:	00f00313          	li	t1,15
800009ac:	3be29073          	csrw	pmpaddr14,t0
800009b0:	00b30a63          	beq	t1,a1,800009c4 <pmpaddr_done>
800009b4:	03c6a283          	lw	t0,60(a3)
800009b8:	01000313          	li	t1,16
800009bc:	3bf29073          	csrw	pmpaddr15,t0
800009c0:	00b30263          	beq	t1,a1,800009c4 <pmpaddr_done>

800009c4 <pmpaddr_done>:
	/*
	 * Move to the pmpcfg space:
	 * a0 = a0 / RV_REGSIZE
	 * a1 = (a1 + RV_REGSIZE - 1) / RV_REGSIZE
	 */
	la t0, pmpcfg_store
800009c4:	00000297          	auipc	t0,0x0
800009c8:	01628293          	addi	t0,t0,22 # 800009da <pmpcfg_store>
	srli a0, a0, RV_REGSHIFT
800009cc:	8109                	srli	a0,a0,0x2
	slli t1, a0, 4  /* 16-byte instruction blocks */
800009ce:	00451313          	slli	t1,a0,0x4
	add t0, t0, t1
800009d2:	929a                	add	t0,t0,t1
	addi a1, a1, RV_REGSIZE - 1
800009d4:	058d                	addi	a1,a1,3
	srli a1, a1, RV_REGSHIFT
800009d6:	8189                	srli	a1,a1,0x2
	jr t0
800009d8:	8282                	jr	t0

800009da <pmpcfg_store>:
	lr t0, (RV_REGSIZE * _index)(a4)
	addi a0, a0, 1
	csrw (CSR_PMPCFG_BASE + RV_REGSIZE/4 * _index), t0
	beq a0, a1, pmpcfg_done
	.set _index, _index + 1
	.endr
800009da:	00072283          	lw	t0,0(a4) # 1000000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x676980>
800009de:	00150513          	addi	a0,a0,1
800009e2:	3a029073          	csrw	pmpcfg0,t0
800009e6:	02b50a63          	beq	a0,a1,80000a1a <pmpcfg_done>
800009ea:	00472283          	lw	t0,4(a4)
800009ee:	00150513          	addi	a0,a0,1
800009f2:	3a129073          	csrw	pmpcfg1,t0
800009f6:	02b50263          	beq	a0,a1,80000a1a <pmpcfg_done>
800009fa:	00872283          	lw	t0,8(a4)
800009fe:	00150513          	addi	a0,a0,1
80000a02:	3a229073          	csrw	pmpcfg2,t0
80000a06:	00b50a63          	beq	a0,a1,80000a1a <pmpcfg_done>
80000a0a:	00c72283          	lw	t0,12(a4)
80000a0e:	00150513          	addi	a0,a0,1
80000a12:	3a329073          	csrw	pmpcfg3,t0
80000a16:	00b50263          	beq	a0,a1,80000a1a <pmpcfg_done>

80000a1a <pmpcfg_done>:
	.option pop

pmpcfg_done:

	beqz a2, done
80000a1a:	c205                	beqz	a2,80000a3a <done>

	la t0, pmpcfg_zerotail
80000a1c:	00000297          	auipc	t0,0x0
80000a20:	00e28293          	addi	t0,t0,14 # 80000a2a <pmpcfg_zerotail>
	slli a0, a0, 2  /* 4-byte instruction blocks */
80000a24:	050a                	slli	a0,a0,0x2
	add t0, t0, a0
80000a26:	92aa                	add	t0,t0,a0
	jr t0
80000a28:	8282                	jr	t0

80000a2a <pmpcfg_zerotail>:
	.option norvc
	.set _index, 0
	.rept (CONFIG_PMP_SLOTS / RV_REGSIZE)
	csrw (CSR_PMPCFG_BASE + RV_REGSIZE/4 * _index), zero
	.set _index, _index + 1
	.endr
80000a2a:	3a001073          	csrw	pmpcfg0,zero
80000a2e:	3a101073          	csrw	pmpcfg1,zero
80000a32:	3a201073          	csrw	pmpcfg2,zero
80000a36:	3a301073          	csrw	pmpcfg3,zero

80000a3a <done>:
	.option pop

done:	ret
80000a3a:	8082                	ret
	...

80000a3e <main>:

#include <zephyr/kernel.h>

void main(void)
{
	printk("Hello World! %s\n", CONFIG_BOARD);
80000a3e:	800035b7          	lui	a1,0x80003
80000a42:	80003537          	lui	a0,0x80003
80000a46:	be058593          	addi	a1,a1,-1056 # 80002be0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002be1>
80000a4a:	bf050513          	addi	a0,a0,-1040 # 80002bf0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002bf1>
80000a4e:	a035                	j	80000a7a <printk>

80000a50 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
80000a50:	4501                	li	a0,0
80000a52:	8082                	ret

80000a54 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
80000a54:	800047b7          	lui	a5,0x80004
80000a58:	f907a783          	lw	a5,-112(a5) # 80003f90 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f91>
80000a5c:	8782                	jr	a5

80000a5e <__printk_hook_install>:
	_char_out = fn;
80000a5e:	800047b7          	lui	a5,0x80004
80000a62:	f8a7a823          	sw	a0,-112(a5) # 80003f90 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f91>
}
80000a66:	8082                	ret

80000a68 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
80000a68:	862a                	mv	a2,a0
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
80000a6a:	80001537          	lui	a0,0x80001
80000a6e:	86ae                	mv	a3,a1
80000a70:	4701                	li	a4,0
80000a72:	4581                	li	a1,0
80000a74:	a5450513          	addi	a0,a0,-1452 # 80000a54 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000a55>
80000a78:	aabd                	j	80000bf6 <z_cbvprintf_impl>

80000a7a <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
80000a7a:	7139                	addi	sp,sp,-64
80000a7c:	d22e                	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
80000a7e:	104c                	addi	a1,sp,36
{
80000a80:	ce06                	sw	ra,28(sp)
80000a82:	d432                	sw	a2,40(sp)
80000a84:	d636                	sw	a3,44(sp)
80000a86:	d83a                	sw	a4,48(sp)
80000a88:	da3e                	sw	a5,52(sp)
80000a8a:	dc42                	sw	a6,56(sp)
80000a8c:	de46                	sw	a7,60(sp)
	va_start(ap, fmt);
80000a8e:	c62e                	sw	a1,12(sp)

	vprintk(fmt, ap);
80000a90:	3fe1                	jal	80000a68 <vprintk>

	va_end(ap);
}
80000a92:	40f2                	lw	ra,28(sp)
80000a94:	6121                	addi	sp,sp,64
80000a96:	8082                	ret

80000a98 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
80000a98:	1101                	addi	sp,sp,-32
80000a9a:	ca26                	sw	s1,20(sp)
80000a9c:	c84a                	sw	s2,16(sp)
80000a9e:	ce06                	sw	ra,28(sp)
80000aa0:	cc22                	sw	s0,24(sp)
80000aa2:	84aa                	mv	s1,a0
80000aa4:	892e                	mv	s2,a1
80000aa6:	c632                	sw	a2,12(sp)
80000aa8:	c436                	sw	a3,8(sp)
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
80000aaa:	1f7010ef          	jal	ra,800024a0 <z_impl_z_current_get>
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
80000aae:	4622                	lw	a2,8(sp)
80000ab0:	45b2                	lw	a1,12(sp)
	z_tls_current = z_current_get();
80000ab2:	00a22023          	sw	a0,0(tp) # 0 <CONFIG_2ND_LVL_INTR_01_OFFSET>
	entry(p1, p2, p3);
80000ab6:	854a                	mv	a0,s2
80000ab8:	9482                	jalr	s1
 */
__attribute_const__
static inline k_tid_t k_current_get(void)
{
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	return z_tls_current;
80000aba:	00022503          	lw	a0,0(tp) # 0 <CONFIG_2ND_LVL_INTR_01_OFFSET>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
80000abe:	2b3010ef          	jal	ra,80002570 <z_impl_k_thread_abort>

80000ac2 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
80000ac2:	7179                	addi	sp,sp,-48
80000ac4:	d422                	sw	s0,40(sp)
80000ac6:	d226                	sw	s1,36(sp)
80000ac8:	d04a                	sw	s2,32(sp)
80000aca:	ce4e                	sw	s3,28(sp)
80000acc:	c65e                	sw	s7,12(sp)
80000ace:	c462                	sw	s8,8(sp)
80000ad0:	c266                	sw	s9,4(sp)
80000ad2:	d606                	sw	ra,44(sp)
80000ad4:	cc52                	sw	s4,24(sp)
80000ad6:	ca56                	sw	s5,20(sp)
80000ad8:	c85a                	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
80000ada:	00364783          	lbu	a5,3(a2)
{
80000ade:	8bba                	mv	s7,a4
	switch (specifier) {
80000ae0:	06f00713          	li	a4,111
{
80000ae4:	842a                	mv	s0,a0
80000ae6:	84ae                	mv	s1,a1
80000ae8:	8cb2                	mv	s9,a2
80000aea:	8936                	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
80000aec:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
80000af0:	4c21                	li	s8,8
80000af2:	00e78a63          	beq	a5,a4,80000b06 <encode_uint+0x44>
80000af6:	08f76363          	bltu	a4,a5,80000b7c <encode_uint+0xba>
80000afa:	05800713          	li	a4,88
		return 16;
80000afe:	4c41                	li	s8,16
	switch (specifier) {
80000b00:	00e78363          	beq	a5,a4,80000b06 <encode_uint+0x44>
		return 10;
80000b04:	4c29                	li	s8,10
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
80000b06:	4a81                	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
80000b08:	4a25                	li	s4,9
80000b0a:	4b65                	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
80000b0c:	8662                	mv	a2,s8
80000b0e:	4681                	li	a3,0
80000b10:	8522                	mv	a0,s0
80000b12:	85a6                	mv	a1,s1
80000b14:	327d                	jal	800004c2 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
80000b16:	0ff57793          	zext.b	a5,a0
80000b1a:	06aa6963          	bltu	s4,a0,80000b8c <encode_uint+0xca>
80000b1e:	03078793          	addi	a5,a5,48
80000b22:	0ff7f793          	zext.b	a5,a5
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
80000b26:	8662                	mv	a2,s8
80000b28:	4681                	li	a3,0
80000b2a:	8522                	mv	a0,s0
80000b2c:	85a6                	mv	a1,s1
		*--bp = (lsv <= 9) ? ('0' + lsv)
80000b2e:	fefb8fa3          	sb	a5,-1(s7)
80000b32:	1bfd                	addi	s7,s7,-1
		value /= radix;
80000b34:	e30ff0ef          	jal	ra,80000164 <__udivdi3>
	} while ((value != 0) && (bps < bp));
80000b38:	009a9463          	bne	s5,s1,80000b40 <encode_uint+0x7e>
80000b3c:	01846463          	bltu	s0,s8,80000b44 <encode_uint+0x82>
80000b40:	05796363          	bltu	s2,s7,80000b86 <encode_uint+0xc4>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
80000b44:	000cd783          	lhu	a5,0(s9)
80000b48:	0207f793          	andi	a5,a5,32
80000b4c:	cb91                	beqz	a5,80000b60 <encode_uint+0x9e>
		if (radix == 8) {
80000b4e:	47a1                	li	a5,8
80000b50:	04fc1663          	bne	s8,a5,80000b9c <encode_uint+0xda>
			conv->altform_0 = true;
80000b54:	002cc783          	lbu	a5,2(s9)
80000b58:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
80000b5c:	00fc8123          	sb	a5,2(s9)
			;
		}
	}

	return bp;
}
80000b60:	50b2                	lw	ra,44(sp)
80000b62:	5422                	lw	s0,40(sp)
80000b64:	5492                	lw	s1,36(sp)
80000b66:	5902                	lw	s2,32(sp)
80000b68:	49f2                	lw	s3,28(sp)
80000b6a:	4a62                	lw	s4,24(sp)
80000b6c:	4ad2                	lw	s5,20(sp)
80000b6e:	4b42                	lw	s6,16(sp)
80000b70:	4c22                	lw	s8,8(sp)
80000b72:	4c92                	lw	s9,4(sp)
80000b74:	855e                	mv	a0,s7
80000b76:	4bb2                	lw	s7,12(sp)
80000b78:	6145                	addi	sp,sp,48
80000b7a:	8082                	ret
	switch (specifier) {
80000b7c:	0f77f793          	andi	a5,a5,247
80000b80:	07000713          	li	a4,112
80000b84:	bfad                	j	80000afe <encode_uint+0x3c>
		value /= radix;
80000b86:	842a                	mv	s0,a0
80000b88:	84ae                	mv	s1,a1
80000b8a:	b749                	j	80000b0c <encode_uint+0x4a>
		*--bp = (lsv <= 9) ? ('0' + lsv)
80000b8c:	013b6563          	bltu	s6,s3,80000b96 <encode_uint+0xd4>
80000b90:	03778793          	addi	a5,a5,55
80000b94:	b779                	j	80000b22 <encode_uint+0x60>
80000b96:	05778793          	addi	a5,a5,87
80000b9a:	b761                	j	80000b22 <encode_uint+0x60>
		} else if (radix == 16) {
80000b9c:	47c1                	li	a5,16
80000b9e:	fcfc11e3          	bne	s8,a5,80000b60 <encode_uint+0x9e>
			conv->altform_0c = true;
80000ba2:	002cc783          	lbu	a5,2(s9)
80000ba6:	0107e793          	ori	a5,a5,16
80000baa:	bf4d                	j	80000b5c <encode_uint+0x9a>

80000bac <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
80000bac:	1101                	addi	sp,sp,-32
80000bae:	cc22                	sw	s0,24(sp)
80000bb0:	ca26                	sw	s1,20(sp)
80000bb2:	c84a                	sw	s2,16(sp)
80000bb4:	c64e                	sw	s3,12(sp)
80000bb6:	c452                	sw	s4,8(sp)
80000bb8:	ce06                	sw	ra,28(sp)
80000bba:	89aa                	mv	s3,a0
80000bbc:	8a2e                	mv	s4,a1
80000bbe:	84b2                	mv	s1,a2
80000bc0:	8936                	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
80000bc2:	8432                	mv	s0,a2
80000bc4:	01246a63          	bltu	s0,s2,80000bd8 <outs+0x2c>
80000bc8:	00090563          	beqz	s2,80000bd2 <outs+0x26>
			return rc;
		}
		++count;
	}

	return (int)count;
80000bcc:	40940533          	sub	a0,s0,s1
80000bd0:	a819                	j	80000be6 <outs+0x3a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
80000bd2:	00044783          	lbu	a5,0(s0)
80000bd6:	dbfd                	beqz	a5,80000bcc <outs+0x20>
		int rc = out((int)*sp++, ctx);
80000bd8:	00044503          	lbu	a0,0(s0)
80000bdc:	85d2                	mv	a1,s4
80000bde:	0405                	addi	s0,s0,1
80000be0:	9982                	jalr	s3
		if (rc < 0) {
80000be2:	fe0551e3          	bgez	a0,80000bc4 <outs+0x18>
}
80000be6:	40f2                	lw	ra,28(sp)
80000be8:	4462                	lw	s0,24(sp)
80000bea:	44d2                	lw	s1,20(sp)
80000bec:	4942                	lw	s2,16(sp)
80000bee:	49b2                	lw	s3,12(sp)
80000bf0:	4a22                	lw	s4,8(sp)
80000bf2:	6105                	addi	sp,sp,32
80000bf4:	8082                	ret

80000bf6 <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
80000bf6:	7175                	addi	sp,sp,-144
80000bf8:	c522                	sw	s0,136(sp)
80000bfa:	c326                	sw	s1,132(sp)
80000bfc:	dcd2                	sw	s4,120(sp)
80000bfe:	d2e6                	sw	s9,100(sp)
80000c00:	d0ea                	sw	s10,96(sp)
80000c02:	c706                	sw	ra,140(sp)
80000c04:	c14a                	sw	s2,128(sp)
80000c06:	dece                	sw	s3,124(sp)
80000c08:	dad6                	sw	s5,116(sp)
80000c0a:	d8da                	sw	s6,112(sp)
80000c0c:	d6de                	sw	s7,108(sp)
80000c0e:	d4e2                	sw	s8,104(sp)
80000c10:	ceee                	sw	s11,92(sp)
80000c12:	84aa                	mv	s1,a0
80000c14:	c42e                	sw	a1,8(sp)
80000c16:	8432                	mv	s0,a2
80000c18:	8cb6                	mv	s9,a3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
80000c1a:	4d01                	li	s10,0
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
		if (*fp != '%') {
80000c1c:	02500a13          	li	s4,37
	while (*fp != 0) {
80000c20:	00044503          	lbu	a0,0(s0)
80000c24:	e119                	bnez	a0,80000c2a <z_cbvprintf_impl+0x34>
			OUTC(' ');
			--width;
		}
	}

	return count;
80000c26:	856a                	mv	a0,s10
80000c28:	afd9                	j	800013fe <z_cbvprintf_impl+0x808>
			OUTC(*fp++);
80000c2a:	00140993          	addi	s3,s0,1
		if (*fp != '%') {
80000c2e:	01450863          	beq	a0,s4,80000c3e <z_cbvprintf_impl+0x48>
			OUTC(*fp++);
80000c32:	45a2                	lw	a1,8(sp)
			OUTC('%');
80000c34:	9482                	jalr	s1
80000c36:	7c054463          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
80000c3a:	0d05                	addi	s10,s10,1
		if (bps == NULL) {
80000c3c:	ab0d                	j	8000116e <z_cbvprintf_impl+0x578>
		} state = {
80000c3e:	02000613          	li	a2,32
80000c42:	4581                	li	a1,0
80000c44:	1808                	addi	a0,sp,48
80000c46:	261000ef          	jal	ra,800016a6 <memset>
	if (*sp == '%') {
80000c4a:	00144783          	lbu	a5,1(s0)
80000c4e:	05479a63          	bne	a5,s4,80000ca2 <z_cbvprintf_impl+0xac>
		conv->specifier = *sp++;
80000c52:	00240993          	addi	s3,s0,2
80000c56:	054101a3          	sb	s4,67(sp)
		if (conv->width_star) {
80000c5a:	04015783          	lhu	a5,64(sp)
80000c5e:	1007f713          	andi	a4,a5,256
80000c62:	40070163          	beqz	a4,80001064 <z_cbvprintf_impl+0x46e>
			width = va_arg(ap, int);
80000c66:	000caa83          	lw	s5,0(s9)
80000c6a:	004c8713          	addi	a4,s9,4
			if (width < 0) {
80000c6e:	000ad863          	bgez	s5,80000c7e <z_cbvprintf_impl+0x88>
				conv->flag_dash = true;
80000c72:	0047e793          	ori	a5,a5,4
80000c76:	04f11023          	sh	a5,64(sp)
				width = -width;
80000c7a:	41500ab3          	neg	s5,s5
		if (conv->prec_star) {
80000c7e:	04015783          	lhu	a5,64(sp)
80000c82:	4007f693          	andi	a3,a5,1024
80000c86:	3e068863          	beqz	a3,80001076 <z_cbvprintf_impl+0x480>
			int arg = va_arg(ap, int);
80000c8a:	00072b83          	lw	s7,0(a4)
80000c8e:	00470c93          	addi	s9,a4,4
			if (arg < 0) {
80000c92:	3e0bd763          	bgez	s7,80001080 <z_cbvprintf_impl+0x48a>
				conv->prec_present = false;
80000c96:	dff7f793          	andi	a5,a5,-513
80000c9a:	04f11023          	sh	a5,64(sp)
		int precision = -1;
80000c9e:	5bfd                	li	s7,-1
80000ca0:	a6c5                	j	80001080 <z_cbvprintf_impl+0x48a>
80000ca2:	4701                	li	a4,0
80000ca4:	4501                	li	a0,0
80000ca6:	4681                	li	a3,0
80000ca8:	4581                	li	a1,0
80000caa:	4601                	li	a2,0
		switch (*sp) {
80000cac:	02b00813          	li	a6,43
80000cb0:	02d00893          	li	a7,45
80000cb4:	03000313          	li	t1,48
80000cb8:	02000e13          	li	t3,32
80000cbc:	02300e93          	li	t4,35
80000cc0:	0009c783          	lbu	a5,0(s3)
80000cc4:	11078263          	beq	a5,a6,80000dc8 <z_cbvprintf_impl+0x1d2>
80000cc8:	0ef86a63          	bltu	a6,a5,80000dbc <z_cbvprintf_impl+0x1c6>
80000ccc:	11c78163          	beq	a5,t3,80000dce <z_cbvprintf_impl+0x1d8>
80000cd0:	11d78163          	beq	a5,t4,80000dd2 <z_cbvprintf_impl+0x1dc>
80000cd4:	c719                	beqz	a4,80000ce2 <z_cbvprintf_impl+0xec>
80000cd6:	04015703          	lhu	a4,64(sp)
80000cda:	04076713          	ori	a4,a4,64
80000cde:	04e11023          	sh	a4,64(sp)
80000ce2:	c519                	beqz	a0,80000cf0 <z_cbvprintf_impl+0xfa>
80000ce4:	04015703          	lhu	a4,64(sp)
80000ce8:	02076713          	ori	a4,a4,32
80000cec:	04e11023          	sh	a4,64(sp)
80000cf0:	c699                	beqz	a3,80000cfe <z_cbvprintf_impl+0x108>
80000cf2:	04015703          	lhu	a4,64(sp)
80000cf6:	01076713          	ori	a4,a4,16
80000cfa:	04e11023          	sh	a4,64(sp)
80000cfe:	c599                	beqz	a1,80000d0c <z_cbvprintf_impl+0x116>
80000d00:	04015703          	lhu	a4,64(sp)
80000d04:	00876713          	ori	a4,a4,8
80000d08:	04e11023          	sh	a4,64(sp)
80000d0c:	c619                	beqz	a2,80000d1a <z_cbvprintf_impl+0x124>
80000d0e:	04015703          	lhu	a4,64(sp)
80000d12:	00476713          	ori	a4,a4,4
80000d16:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
80000d1a:	4706                	lw	a4,64(sp)
80000d1c:	04400693          	li	a3,68
80000d20:	04477713          	andi	a4,a4,68
80000d24:	00d71863          	bne	a4,a3,80000d34 <z_cbvprintf_impl+0x13e>
		conv->flag_zero = false;
80000d28:	04015703          	lhu	a4,64(sp)
80000d2c:	fbf77713          	andi	a4,a4,-65
80000d30:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
80000d34:	04015703          	lhu	a4,64(sp)
80000d38:	08076713          	ori	a4,a4,128
80000d3c:	04e11023          	sh	a4,64(sp)
	if (*sp == '*') {
80000d40:	02a00713          	li	a4,42
80000d44:	0ce79363          	bne	a5,a4,80000e0a <z_cbvprintf_impl+0x214>
		conv->width_star = true;
80000d48:	04015703          	lhu	a4,64(sp)
		return ++sp;
80000d4c:	00198793          	addi	a5,s3,1
		conv->width_star = true;
80000d50:	10076713          	ori	a4,a4,256
		conv->unsupported |= ((conv->width_value < 0)
80000d54:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
80000d58:	0007c603          	lbu	a2,0(a5)
80000d5c:	04015703          	lhu	a4,64(sp)
80000d60:	fd260693          	addi	a3,a2,-46
80000d64:	0016b693          	seqz	a3,a3
80000d68:	06a6                	slli	a3,a3,0x9
80000d6a:	dff77713          	andi	a4,a4,-513
80000d6e:	8f55                	or	a4,a4,a3
80000d70:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
80000d74:	02e00713          	li	a4,46
80000d78:	0ae61563          	bne	a2,a4,80000e22 <z_cbvprintf_impl+0x22c>
	if (*sp == '*') {
80000d7c:	0017c683          	lbu	a3,1(a5)
80000d80:	02a00713          	li	a4,42
80000d84:	08e68863          	beq	a3,a4,80000e14 <z_cbvprintf_impl+0x21e>
	++sp;
80000d88:	0785                	addi	a5,a5,1
	size_t val = 0;
80000d8a:	4701                	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
80000d8c:	4625                	li	a2,9
		val = 10U * val + *sp++ - '0';
80000d8e:	4829                	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
80000d90:	0007c683          	lbu	a3,0(a5)
80000d94:	00178513          	addi	a0,a5,1
80000d98:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
80000d9c:	10b67163          	bgeu	a2,a1,80000e9e <z_cbvprintf_impl+0x2a8>
	conv->unsupported |= ((conv->prec_value < 0)
80000da0:	4686                	lw	a3,64(sp)
	conv->prec_value = prec;
80000da2:	c4ba                	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
80000da4:	837d                	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
80000da6:	8285                	srli	a3,a3,0x1
80000da8:	8a85                	andi	a3,a3,1
80000daa:	8f55                	or	a4,a4,a3
80000dac:	04015683          	lhu	a3,64(sp)
80000db0:	0706                	slli	a4,a4,0x1
80000db2:	9af5                	andi	a3,a3,-3
80000db4:	8f55                	or	a4,a4,a3
80000db6:	04e11023          	sh	a4,64(sp)
	return sp;
80000dba:	a0a5                	j	80000e22 <z_cbvprintf_impl+0x22c>
		switch (*sp) {
80000dbc:	01178d63          	beq	a5,a7,80000dd6 <z_cbvprintf_impl+0x1e0>
80000dc0:	f0679ae3          	bne	a5,t1,80000cd4 <z_cbvprintf_impl+0xde>
80000dc4:	4705                	li	a4,1
80000dc6:	a011                	j	80000dca <z_cbvprintf_impl+0x1d4>
80000dc8:	4585                	li	a1,1
			++sp;
80000dca:	0985                	addi	s3,s3,1
	} while (loop);
80000dcc:	bdd5                	j	80000cc0 <z_cbvprintf_impl+0xca>
		switch (*sp) {
80000dce:	4685                	li	a3,1
80000dd0:	bfed                	j	80000dca <z_cbvprintf_impl+0x1d4>
80000dd2:	4505                	li	a0,1
80000dd4:	bfdd                	j	80000dca <z_cbvprintf_impl+0x1d4>
80000dd6:	4605                	li	a2,1
80000dd8:	bfcd                	j	80000dca <z_cbvprintf_impl+0x1d4>
		val = 10U * val + *sp++ - '0';
80000dda:	03070733          	mul	a4,a4,a6
80000dde:	87aa                	mv	a5,a0
80000de0:	fd070713          	addi	a4,a4,-48
80000de4:	9736                	add	a4,a4,a3
80000de6:	0007c683          	lbu	a3,0(a5)
80000dea:	00178513          	addi	a0,a5,1
80000dee:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
80000df2:	feb674e3          	bgeu	a2,a1,80000dda <z_cbvprintf_impl+0x1e4>
	if (sp != wp) {
80000df6:	f6f981e3          	beq	s3,a5,80000d58 <z_cbvprintf_impl+0x162>
		conv->unsupported |= ((conv->width_value < 0)
80000dfa:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
80000dfe:	c2ba                	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
80000e00:	837d                	srli	a4,a4,0x1f
80000e02:	0706                	slli	a4,a4,0x1
80000e04:	9af5                	andi	a3,a3,-3
80000e06:	8f55                	or	a4,a4,a3
80000e08:	b7b1                	j	80000d54 <z_cbvprintf_impl+0x15e>
80000e0a:	87ce                	mv	a5,s3
	size_t val = 0;
80000e0c:	4701                	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
80000e0e:	4625                	li	a2,9
		val = 10U * val + *sp++ - '0';
80000e10:	4829                	li	a6,10
80000e12:	bfd1                	j	80000de6 <z_cbvprintf_impl+0x1f0>
		conv->prec_star = true;
80000e14:	04015703          	lhu	a4,64(sp)
		return ++sp;
80000e18:	0789                	addi	a5,a5,2
		conv->prec_star = true;
80000e1a:	40076713          	ori	a4,a4,1024
80000e1e:	04e11023          	sh	a4,64(sp)
	switch (*sp) {
80000e22:	0007c683          	lbu	a3,0(a5)
80000e26:	06c00713          	li	a4,108
80000e2a:	0ce68963          	beq	a3,a4,80000efc <z_cbvprintf_impl+0x306>
80000e2e:	06d76f63          	bltu	a4,a3,80000eac <z_cbvprintf_impl+0x2b6>
80000e32:	06800713          	li	a4,104
80000e36:	08e68b63          	beq	a3,a4,80000ecc <z_cbvprintf_impl+0x2d6>
80000e3a:	06a00713          	li	a4,106
80000e3e:	0ce68f63          	beq	a3,a4,80000f1c <z_cbvprintf_impl+0x326>
80000e42:	04c00713          	li	a4,76
80000e46:	0ee68b63          	beq	a3,a4,80000f3c <z_cbvprintf_impl+0x346>
	conv->specifier = *sp++;
80000e4a:	00178993          	addi	s3,a5,1
80000e4e:	0007c783          	lbu	a5,0(a5)
	switch (conv->specifier) {
80000e52:	07800713          	li	a4,120
	conv->specifier = *sp++;
80000e56:	04f101a3          	sb	a5,67(sp)
	switch (conv->specifier) {
80000e5a:	1ef76e63          	bltu	a4,a5,80001056 <z_cbvprintf_impl+0x460>
80000e5e:	06d00713          	li	a4,109
80000e62:	0ef76663          	bltu	a4,a5,80000f4e <z_cbvprintf_impl+0x358>
80000e66:	06900713          	li	a4,105
80000e6a:	1ef76663          	bltu	a4,a5,80001056 <z_cbvprintf_impl+0x460>
80000e6e:	05700713          	li	a4,87
80000e72:	10f76d63          	bltu	a4,a5,80000f8c <z_cbvprintf_impl+0x396>
80000e76:	04100713          	li	a4,65
80000e7a:	00e78963          	beq	a5,a4,80000e8c <z_cbvprintf_impl+0x296>
80000e7e:	fbb78793          	addi	a5,a5,-69
80000e82:	0ff7f793          	zext.b	a5,a5
80000e86:	4709                	li	a4,2
80000e88:	1cf76763          	bltu	a4,a5,80001056 <z_cbvprintf_impl+0x460>
		conv->specifier_cat = SPECIFIER_FP;
80000e8c:	04214783          	lbu	a5,66(sp)
80000e90:	9be1                	andi	a5,a5,-8
80000e92:	0047e793          	ori	a5,a5,4
80000e96:	04f10123          	sb	a5,66(sp)
			unsupported = true;
80000e9a:	4785                	li	a5,1
			break;
80000e9c:	aa2d                	j	80000fd6 <z_cbvprintf_impl+0x3e0>
		val = 10U * val + *sp++ - '0';
80000e9e:	03070733          	mul	a4,a4,a6
80000ea2:	87aa                	mv	a5,a0
80000ea4:	fd070713          	addi	a4,a4,-48
80000ea8:	9736                	add	a4,a4,a3
80000eaa:	b5dd                	j	80000d90 <z_cbvprintf_impl+0x19a>
	switch (*sp) {
80000eac:	07400713          	li	a4,116
80000eb0:	06e68e63          	beq	a3,a4,80000f2c <z_cbvprintf_impl+0x336>
80000eb4:	07a00713          	li	a4,122
80000eb8:	f8e699e3          	bne	a3,a4,80000e4a <z_cbvprintf_impl+0x254>
		conv->length_mod = LENGTH_Z;
80000ebc:	04015703          	lhu	a4,64(sp)
80000ec0:	76e1                	lui	a3,0xffff8
80000ec2:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
80000ec6:	8f75                	and	a4,a4,a3
80000ec8:	668d                	lui	a3,0x3
80000eca:	a025                	j	80000ef2 <z_cbvprintf_impl+0x2fc>
		if (*++sp == 'h') {
80000ecc:	04015703          	lhu	a4,64(sp)
80000ed0:	0017c583          	lbu	a1,1(a5)
80000ed4:	7661                	lui	a2,0xffff8
80000ed6:	7ff60613          	addi	a2,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
80000eda:	8f71                	and	a4,a4,a2
		if (*++sp == 'h') {
80000edc:	00d59a63          	bne	a1,a3,80000ef0 <z_cbvprintf_impl+0x2fa>
			conv->length_mod = LENGTH_HH;
80000ee0:	6685                	lui	a3,0x1
80000ee2:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
80000ee6:	8f55                	or	a4,a4,a3
80000ee8:	04e11023          	sh	a4,64(sp)
			++sp;
80000eec:	0789                	addi	a5,a5,2
80000eee:	bfb1                	j	80000e4a <z_cbvprintf_impl+0x254>
			conv->length_mod = LENGTH_H;
80000ef0:	6685                	lui	a3,0x1
80000ef2:	8f55                	or	a4,a4,a3
80000ef4:	04e11023          	sh	a4,64(sp)
		if (*++sp == 'h') {
80000ef8:	0785                	addi	a5,a5,1
80000efa:	bf81                	j	80000e4a <z_cbvprintf_impl+0x254>
		if (*++sp == 'l') {
80000efc:	04015703          	lhu	a4,64(sp)
80000f00:	0017c583          	lbu	a1,1(a5)
80000f04:	7661                	lui	a2,0xffff8
80000f06:	7ff60613          	addi	a2,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
80000f0a:	8f71                	and	a4,a4,a2
		if (*++sp == 'l') {
80000f0c:	00d59463          	bne	a1,a3,80000f14 <z_cbvprintf_impl+0x31e>
			conv->length_mod = LENGTH_LL;
80000f10:	6689                	lui	a3,0x2
80000f12:	bfd1                	j	80000ee6 <z_cbvprintf_impl+0x2f0>
			conv->length_mod = LENGTH_L;
80000f14:	6689                	lui	a3,0x2
		conv->length_mod = LENGTH_T;
80000f16:	80068693          	addi	a3,a3,-2048 # 1800 <__kernel_ram_size+0x85c>
80000f1a:	bfe1                	j	80000ef2 <z_cbvprintf_impl+0x2fc>
		conv->length_mod = LENGTH_J;
80000f1c:	04015703          	lhu	a4,64(sp)
80000f20:	76e1                	lui	a3,0xffff8
80000f22:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
80000f26:	8f75                	and	a4,a4,a3
80000f28:	668d                	lui	a3,0x3
80000f2a:	b7f5                	j	80000f16 <z_cbvprintf_impl+0x320>
		conv->length_mod = LENGTH_T;
80000f2c:	04015703          	lhu	a4,64(sp)
80000f30:	76e1                	lui	a3,0xffff8
80000f32:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
80000f36:	8f75                	and	a4,a4,a3
80000f38:	6691                	lui	a3,0x4
80000f3a:	bff1                	j	80000f16 <z_cbvprintf_impl+0x320>
		conv->unsupported = true;
80000f3c:	04015703          	lhu	a4,64(sp)
80000f40:	76e1                	lui	a3,0xffff8
80000f42:	7fd68693          	addi	a3,a3,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
80000f46:	8f75                	and	a4,a4,a3
80000f48:	6691                	lui	a3,0x4
80000f4a:	0689                	addi	a3,a3,2 # 4002 <__rom_region_size+0x1002>
80000f4c:	b75d                	j	80000ef2 <z_cbvprintf_impl+0x2fc>
	switch (conv->specifier) {
80000f4e:	f9278713          	addi	a4,a5,-110
80000f52:	4785                	li	a5,1
80000f54:	00e797b3          	sll	a5,a5,a4
80000f58:	4827f713          	andi	a4,a5,1154
80000f5c:	eb49                	bnez	a4,80000fee <z_cbvprintf_impl+0x3f8>
80000f5e:	0247f713          	andi	a4,a5,36
80000f62:	e375                	bnez	a4,80001046 <z_cbvprintf_impl+0x450>
80000f64:	8b85                	andi	a5,a5,1
80000f66:	cbe5                	beqz	a5,80001056 <z_cbvprintf_impl+0x460>
		conv->specifier_cat = SPECIFIER_PTR;
80000f68:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
80000f6c:	6721                	lui	a4,0x8
80000f6e:	80070713          	addi	a4,a4,-2048 # 7800 <__rom_region_size+0x4800>
		conv->specifier_cat = SPECIFIER_PTR;
80000f72:	9be1                	andi	a5,a5,-8
80000f74:	0037e793          	ori	a5,a5,3
80000f78:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
80000f7c:	04015783          	lhu	a5,64(sp)
80000f80:	8ff9                	and	a5,a5,a4
80000f82:	7771                	lui	a4,0xffffc
80000f84:	97ba                	add	a5,a5,a4
80000f86:	0017b793          	seqz	a5,a5
80000f8a:	a0b1                	j	80000fd6 <z_cbvprintf_impl+0x3e0>
	switch (conv->specifier) {
80000f8c:	fa878693          	addi	a3,a5,-88
80000f90:	4705                	li	a4,1
80000f92:	00d71733          	sll	a4,a4,a3
80000f96:	66b9                	lui	a3,0xe
80000f98:	20068693          	addi	a3,a3,512 # e200 <__rom_region_size+0xb200>
80000f9c:	8ef9                	and	a3,a3,a4
80000f9e:	ee0697e3          	bnez	a3,80000e8c <z_cbvprintf_impl+0x296>
80000fa2:	6685                	lui	a3,0x1
80000fa4:	80168693          	addi	a3,a3,-2047 # 801 <CONFIG_ISR_STACK_SIZE+0x1>
80000fa8:	8ef9                	and	a3,a3,a4
80000faa:	eea9                	bnez	a3,80001004 <z_cbvprintf_impl+0x40e>
80000fac:	000217b7          	lui	a5,0x21
80000fb0:	8f7d                	and	a4,a4,a5
80000fb2:	c355                	beqz	a4,80001056 <z_cbvprintf_impl+0x460>
		conv->specifier_cat = SPECIFIER_SINT;
80000fb4:	04214783          	lbu	a5,66(sp)
80000fb8:	9be1                	andi	a5,a5,-8
80000fba:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
80000fbe:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_SINT;
80000fc2:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
80000fc6:	67a1                	lui	a5,0x8
80000fc8:	80078793          	addi	a5,a5,-2048 # 7800 <__rom_region_size+0x4800>
80000fcc:	8ff9                	and	a5,a5,a4
80000fce:	6691                	lui	a3,0x4
80000fd0:	02d78563          	beq	a5,a3,80000ffa <z_cbvprintf_impl+0x404>
	bool unsupported = false;
80000fd4:	4781                	li	a5,0
	conv->unsupported |= unsupported;
80000fd6:	4706                	lw	a4,64(sp)
80000fd8:	8305                	srli	a4,a4,0x1
80000fda:	8b05                	andi	a4,a4,1
80000fdc:	8fd9                	or	a5,a5,a4
80000fde:	04015703          	lhu	a4,64(sp)
80000fe2:	0786                	slli	a5,a5,0x1
80000fe4:	9b75                	andi	a4,a4,-3
80000fe6:	8fd9                	or	a5,a5,a4
80000fe8:	04f11023          	sh	a5,64(sp)
	return sp;
80000fec:	b1bd                	j	80000c5a <z_cbvprintf_impl+0x64>
		conv->specifier_cat = SPECIFIER_UINT;
80000fee:	04214783          	lbu	a5,66(sp)
80000ff2:	9be1                	andi	a5,a5,-8
80000ff4:	0027e793          	ori	a5,a5,2
80000ff8:	b7d9                	j	80000fbe <z_cbvprintf_impl+0x3c8>
			conv->invalid = true;
80000ffa:	00176713          	ori	a4,a4,1
80000ffe:	04e11023          	sh	a4,64(sp)
		if (conv->specifier == 'c') {
80001002:	bfc9                	j	80000fd4 <z_cbvprintf_impl+0x3de>
		conv->specifier_cat = SPECIFIER_UINT;
80001004:	04214703          	lbu	a4,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
80001008:	04015683          	lhu	a3,64(sp)
8000100c:	6611                	lui	a2,0x4
		conv->specifier_cat = SPECIFIER_UINT;
8000100e:	9b61                	andi	a4,a4,-8
80001010:	00276713          	ori	a4,a4,2
80001014:	04e10123          	sb	a4,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
80001018:	6721                	lui	a4,0x8
8000101a:	80070713          	addi	a4,a4,-2048 # 7800 <__rom_region_size+0x4800>
8000101e:	8f75                	and	a4,a4,a3
80001020:	00c71663          	bne	a4,a2,8000102c <z_cbvprintf_impl+0x436>
			conv->invalid = true;
80001024:	0016e693          	ori	a3,a3,1
80001028:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
8000102c:	06300713          	li	a4,99
80001030:	fae792e3          	bne	a5,a4,80000fd4 <z_cbvprintf_impl+0x3de>
		if (conv->length_mod != LENGTH_NONE) {
80001034:	04015783          	lhu	a5,64(sp)
80001038:	6721                	lui	a4,0x8
8000103a:	80070713          	addi	a4,a4,-2048 # 7800 <__rom_region_size+0x4800>
8000103e:	8ff9                	and	a5,a5,a4
80001040:	00f037b3          	snez	a5,a5
80001044:	bf49                	j	80000fd6 <z_cbvprintf_impl+0x3e0>
		conv->specifier_cat = SPECIFIER_PTR;
80001046:	04214783          	lbu	a5,66(sp)
8000104a:	9be1                	andi	a5,a5,-8
8000104c:	0037e793          	ori	a5,a5,3
80001050:	04f10123          	sb	a5,66(sp)
80001054:	b7c5                	j	80001034 <z_cbvprintf_impl+0x43e>
		conv->invalid = true;
80001056:	04015783          	lhu	a5,64(sp)
8000105a:	0017e793          	ori	a5,a5,1
8000105e:	04f11023          	sh	a5,64(sp)
		break;
80001062:	bf8d                	j	80000fd4 <z_cbvprintf_impl+0x3de>
		} else if (conv->width_present) {
80001064:	0807f793          	andi	a5,a5,128
80001068:	c781                	beqz	a5,80001070 <z_cbvprintf_impl+0x47a>
			width = conv->width_value;
8000106a:	4a96                	lw	s5,68(sp)
8000106c:	8766                	mv	a4,s9
8000106e:	b901                	j	80000c7e <z_cbvprintf_impl+0x88>
80001070:	8766                	mv	a4,s9
		int width = -1;
80001072:	5afd                	li	s5,-1
80001074:	b129                	j	80000c7e <z_cbvprintf_impl+0x88>
		} else if (conv->prec_present) {
80001076:	2007f793          	andi	a5,a5,512
8000107a:	c7b9                	beqz	a5,800010c8 <z_cbvprintf_impl+0x4d2>
			precision = conv->prec_value;
8000107c:	4ba6                	lw	s7,72(sp)
8000107e:	8cba                	mv	s9,a4
			= (enum specifier_cat_enum)conv->specifier_cat;
80001080:	4606                	lw	a2,64(sp)
		conv->pad0_value = 0;
80001082:	c282                	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
80001084:	c482                	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
80001086:	01065513          	srli	a0,a2,0x10
			= (enum length_mod_enum)conv->length_mod;
8000108a:	00b65693          	srli	a3,a2,0xb
		enum specifier_cat_enum specifier_cat
8000108e:	891d                	andi	a0,a0,7
		if (specifier_cat == SPECIFIER_SINT) {
80001090:	4585                	li	a1,1
			= (enum length_mod_enum)conv->length_mod;
80001092:	8abd                	andi	a3,a3,15
		if (specifier_cat == SPECIFIER_SINT) {
80001094:	06b51363          	bne	a0,a1,800010fa <z_cbvprintf_impl+0x504>
			switch (length_mod) {
80001098:	4795                	li	a5,5
8000109a:	10f68563          	beq	a3,a5,800011a4 <z_cbvprintf_impl+0x5ae>
8000109e:	02d7e763          	bltu	a5,a3,800010cc <z_cbvprintf_impl+0x4d6>
800010a2:	478d                	li	a5,3
800010a4:	02f68c63          	beq	a3,a5,800010dc <z_cbvprintf_impl+0x4e6>
800010a8:	4791                	li	a5,4
800010aa:	0ef68d63          	beq	a3,a5,800011a4 <z_cbvprintf_impl+0x5ae>
				value->sint = va_arg(ap, int);
800010ae:	000ca783          	lw	a5,0(s9)
800010b2:	004c8713          	addi	a4,s9,4
800010b6:	41f7d593          	srai	a1,a5,0x1f
800010ba:	d83e                	sw	a5,48(sp)
800010bc:	da2e                	sw	a1,52(sp)
			if (length_mod == LENGTH_HH) {
800010be:	02a69663          	bne	a3,a0,800010ea <z_cbvprintf_impl+0x4f4>
				value->sint = (signed char)value->sint;
800010c2:	03010783          	lb	a5,48(sp)
800010c6:	a039                	j	800010d4 <z_cbvprintf_impl+0x4de>
800010c8:	8cba                	mv	s9,a4
800010ca:	bed1                	j	80000c9e <z_cbvprintf_impl+0xa8>
800010cc:	000ca783          	lw	a5,0(s9)
800010d0:	004c8713          	addi	a4,s9,4
				value->sint = (short)value->sint;
800010d4:	d83e                	sw	a5,48(sp)
800010d6:	87fd                	srai	a5,a5,0x1f
800010d8:	da3e                	sw	a5,52(sp)
800010da:	a819                	j	800010f0 <z_cbvprintf_impl+0x4fa>
					value->sint = va_arg(ap, long);
800010dc:	000ca783          	lw	a5,0(s9)
800010e0:	d83e                	sw	a5,48(sp)
800010e2:	87fd                	srai	a5,a5,0x1f
800010e4:	da3e                	sw	a5,52(sp)
			value->ptr = va_arg(ap, void *);
800010e6:	0c91                	addi	s9,s9,4
800010e8:	a88d                	j	8000115a <z_cbvprintf_impl+0x564>
			} else if (length_mod == LENGTH_H) {
800010ea:	4589                	li	a1,2
800010ec:	00b68463          	beq	a3,a1,800010f4 <z_cbvprintf_impl+0x4fe>
800010f0:	8cba                	mv	s9,a4
800010f2:	a0a5                	j	8000115a <z_cbvprintf_impl+0x564>
				value->sint = (short)value->sint;
800010f4:	07c2                	slli	a5,a5,0x10
800010f6:	87c1                	srai	a5,a5,0x10
800010f8:	bff1                	j	800010d4 <z_cbvprintf_impl+0x4de>
		} else if (specifier_cat == SPECIFIER_UINT) {
800010fa:	4789                	li	a5,2
800010fc:	08f51363          	bne	a0,a5,80001182 <z_cbvprintf_impl+0x58c>
			switch (length_mod) {
80001100:	4795                	li	a5,5
80001102:	0af68163          	beq	a3,a5,800011a4 <z_cbvprintf_impl+0x5ae>
80001106:	02d7e663          	bltu	a5,a3,80001132 <z_cbvprintf_impl+0x53c>
8000110a:	478d                	li	a5,3
8000110c:	02f68a63          	beq	a3,a5,80001140 <z_cbvprintf_impl+0x54a>
80001110:	4791                	li	a5,4
80001112:	08f68963          	beq	a3,a5,800011a4 <z_cbvprintf_impl+0x5ae>
				value->uint = va_arg(ap, unsigned int);
80001116:	000ca783          	lw	a5,0(s9)
8000111a:	004c8713          	addi	a4,s9,4
			if (length_mod == LENGTH_HH) {
8000111e:	04b68e63          	beq	a3,a1,8000117a <z_cbvprintf_impl+0x584>
				value->uint = va_arg(ap, unsigned int);
80001122:	d83e                	sw	a5,48(sp)
80001124:	da02                	sw	zero,52(sp)
			} else if (length_mod == LENGTH_H) {
80001126:	fca695e3          	bne	a3,a0,800010f0 <z_cbvprintf_impl+0x4fa>
				value->uint = (unsigned short)value->uint;
8000112a:	07c2                	slli	a5,a5,0x10
8000112c:	83c1                	srli	a5,a5,0x10
8000112e:	d83e                	sw	a5,48(sp)
80001130:	b7c1                	j	800010f0 <z_cbvprintf_impl+0x4fa>
80001132:	000ca503          	lw	a0,0(s9)
80001136:	004c8713          	addi	a4,s9,4
					(uint_value_type)va_arg(ap, size_t);
8000113a:	d82a                	sw	a0,48(sp)
				value->uint = (unsigned char)value->uint;
8000113c:	da02                	sw	zero,52(sp)
8000113e:	bf4d                	j	800010f0 <z_cbvprintf_impl+0x4fa>
				if ((!WCHAR_IS_SIGNED)
80001140:	04314703          	lbu	a4,67(sp)
80001144:	06300793          	li	a5,99
80001148:	02f71563          	bne	a4,a5,80001172 <z_cbvprintf_impl+0x57c>
					value->uint = (wchar_t)va_arg(ap,
8000114c:	000ca783          	lw	a5,0(s9)
80001150:	41f7d713          	srai	a4,a5,0x1f
				value->sint = va_arg(ap, int);
80001154:	0c91                	addi	s9,s9,4
					value->uint = (wchar_t)va_arg(ap,
80001156:	d83e                	sw	a5,48(sp)
80001158:	da3a                	sw	a4,52(sp)
		if (conv->invalid || conv->unsupported) {
8000115a:	8a0d                	andi	a2,a2,3
8000115c:	c62d                	beqz	a2,800011c6 <z_cbvprintf_impl+0x5d0>
			OUTS(sp, fp);
8000115e:	45a2                	lw	a1,8(sp)
80001160:	86ce                	mv	a3,s3
80001162:	8622                	mv	a2,s0
80001164:	8526                	mv	a0,s1
80001166:	3499                	jal	80000bac <outs>
80001168:	28054b63          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
8000116c:	9d2a                	add	s10,s10,a0
			continue;
8000116e:	844e                	mv	s0,s3
80001170:	bc45                	j	80000c20 <z_cbvprintf_impl+0x2a>
					value->uint = va_arg(ap, unsigned long);
80001172:	000ca783          	lw	a5,0(s9)
80001176:	4701                	li	a4,0
			if (length_mod == LENGTH_HH) {
80001178:	bff1                	j	80001154 <z_cbvprintf_impl+0x55e>
				value->uint = (unsigned char)value->uint;
8000117a:	0ff7f793          	zext.b	a5,a5
8000117e:	d83e                	sw	a5,48(sp)
80001180:	bf75                	j	8000113c <z_cbvprintf_impl+0x546>
		} else if (specifier_cat == SPECIFIER_FP) {
80001182:	4791                	li	a5,4
80001184:	02f51a63          	bne	a0,a5,800011b8 <z_cbvprintf_impl+0x5c2>
			if (length_mod == LENGTH_UPPER_L) {
80001188:	47a1                	li	a5,8
8000118a:	00f69d63          	bne	a3,a5,800011a4 <z_cbvprintf_impl+0x5ae>
				value->ldbl = va_arg(ap, long double);
8000118e:	000ca783          	lw	a5,0(s9)
80001192:	4398                	lw	a4,0(a5)
80001194:	d83a                	sw	a4,48(sp)
80001196:	43d8                	lw	a4,4(a5)
80001198:	da3a                	sw	a4,52(sp)
8000119a:	4798                	lw	a4,8(a5)
8000119c:	47dc                	lw	a5,12(a5)
8000119e:	dc3a                	sw	a4,56(sp)
800011a0:	de3e                	sw	a5,60(sp)
800011a2:	b791                	j	800010e6 <z_cbvprintf_impl+0x4f0>
				value->dbl = va_arg(ap, double);
800011a4:	007c8793          	addi	a5,s9,7
800011a8:	9be1                	andi	a5,a5,-8
800011aa:	4398                	lw	a4,0(a5)
800011ac:	00878c93          	addi	s9,a5,8
800011b0:	43dc                	lw	a5,4(a5)
800011b2:	d83a                	sw	a4,48(sp)
800011b4:	da3e                	sw	a5,52(sp)
800011b6:	b755                	j	8000115a <z_cbvprintf_impl+0x564>
		} else if (specifier_cat == SPECIFIER_PTR) {
800011b8:	478d                	li	a5,3
800011ba:	faf510e3          	bne	a0,a5,8000115a <z_cbvprintf_impl+0x564>
			value->ptr = va_arg(ap, void *);
800011be:	000ca783          	lw	a5,0(s9)
800011c2:	d83e                	sw	a5,48(sp)
800011c4:	b70d                	j	800010e6 <z_cbvprintf_impl+0x4f0>
		switch (conv->specifier) {
800011c6:	04314783          	lbu	a5,67(sp)
800011ca:	07800713          	li	a4,120
800011ce:	faf760e3          	bltu	a4,a5,8000116e <z_cbvprintf_impl+0x578>
800011d2:	06200713          	li	a4,98
800011d6:	00f76c63          	bltu	a4,a5,800011ee <z_cbvprintf_impl+0x5f8>
800011da:	02500713          	li	a4,37
800011de:	02e78763          	beq	a5,a4,8000120c <z_cbvprintf_impl+0x616>
800011e2:	05800713          	li	a4,88
800011e6:	f8e794e3          	bne	a5,a4,8000116e <z_cbvprintf_impl+0x578>
800011ea:	4d81                	li	s11,0
800011ec:	a22d                	j	80001316 <z_cbvprintf_impl+0x720>
800011ee:	f9d78793          	addi	a5,a5,-99
800011f2:	0ff7f793          	zext.b	a5,a5
800011f6:	4755                	li	a4,21
800011f8:	f6f76be3          	bltu	a4,a5,8000116e <z_cbvprintf_impl+0x578>
800011fc:	80003737          	lui	a4,0x80003
80001200:	078a                	slli	a5,a5,0x2
80001202:	c0c70713          	addi	a4,a4,-1012 # 80002c0c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002c0d>
80001206:	97ba                	add	a5,a5,a4
80001208:	439c                	lw	a5,0(a5)
8000120a:	8782                	jr	a5
			OUTC('%');
8000120c:	45a2                	lw	a1,8(sp)
8000120e:	02500513          	li	a0,37
80001212:	b40d                	j	80000c34 <z_cbvprintf_impl+0x3e>
			bps = (const char *)value->ptr;
80001214:	5442                	lw	s0,48(sp)
			if (precision >= 0) {
80001216:	0a0bcb63          	bltz	s7,800012cc <z_cbvprintf_impl+0x6d6>
				len = strnlen(bps, precision);
8000121a:	85de                	mv	a1,s7
8000121c:	8522                	mv	a0,s0
8000121e:	2991                	jal	80001672 <strnlen>
			bpe = bps + len;
80001220:	00a40b33          	add	s6,s0,a0
		char sign = 0;
80001224:	4d81                	li	s11,0
		if (bps == NULL) {
80001226:	d421                	beqz	s0,8000116e <z_cbvprintf_impl+0x578>
		if (conv->altform_0c) {
80001228:	04214783          	lbu	a5,66(sp)
8000122c:	0107fc13          	andi	s8,a5,16
80001230:	1a0c0a63          	beqz	s8,800013e4 <z_cbvprintf_impl+0x7ee>
			nj_len += 2U;
80001234:	0509                	addi	a0,a0,2
		nj_len += conv->pad0_value;
80001236:	4b96                	lw	s7,68(sp)
		if (conv->pad_fp) {
80001238:	0407f793          	andi	a5,a5,64
		nj_len += conv->pad0_value;
8000123c:	955e                	add	a0,a0,s7
		if (conv->pad_fp) {
8000123e:	c399                	beqz	a5,80001244 <z_cbvprintf_impl+0x64e>
			nj_len += conv->pad0_pre_exp;
80001240:	47a6                	lw	a5,72(sp)
80001242:	953e                	add	a0,a0,a5
		if (width > 0) {
80001244:	05505263          	blez	s5,80001288 <z_cbvprintf_impl+0x692>
			if (!conv->flag_dash) {
80001248:	4786                	lw	a5,64(sp)
			width -= (int)nj_len;
8000124a:	40aa8ab3          	sub	s5,s5,a0
			if (!conv->flag_dash) {
8000124e:	8389                	srli	a5,a5,0x2
80001250:	8b85                	andi	a5,a5,1
80001252:	eb9d                	bnez	a5,80001288 <z_cbvprintf_impl+0x692>
				if (conv->flag_zero) {
80001254:	04015783          	lhu	a5,64(sp)
80001258:	0407f793          	andi	a5,a5,64
8000125c:	1c078063          	beqz	a5,8000141c <z_cbvprintf_impl+0x826>
					if (sign != 0) {
80001260:	1c0d8163          	beqz	s11,80001422 <z_cbvprintf_impl+0x82c>
						OUTC(sign);
80001264:	45a2                	lw	a1,8(sp)
80001266:	856e                	mv	a0,s11
80001268:	9482                	jalr	s1
8000126a:	18054a63          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
8000126e:	0d05                	addi	s10,s10,1
					pad = '0';
80001270:	03000713          	li	a4,48
						OUTC(sign);
80001274:	4d81                	li	s11,0
					pad = '0';
80001276:	8956                	mv	s2,s5
				while (width-- > 0) {
80001278:	86ca                	mv	a3,s2
8000127a:	197d                	addi	s2,s2,-1
8000127c:	16d04a63          	bgtz	a3,800013f0 <z_cbvprintf_impl+0x7fa>
80001280:	9d56                	add	s10,s10,s5
80001282:	40dd0d33          	sub	s10,s10,a3
80001286:	8aca                	mv	s5,s2
		if (sign != 0) {
80001288:	000d8863          	beqz	s11,80001298 <z_cbvprintf_impl+0x6a2>
			OUTC(sign);
8000128c:	45a2                	lw	a1,8(sp)
8000128e:	856e                	mv	a0,s11
80001290:	9482                	jalr	s1
80001292:	16054663          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
80001296:	0d05                	addi	s10,s10,1
			if (conv->altform_0c | conv->altform_0) {
80001298:	4786                	lw	a5,64(sp)
8000129a:	0147d713          	srli	a4,a5,0x14
8000129e:	8b05                	andi	a4,a4,1
800012a0:	e701                	bnez	a4,800012a8 <z_cbvprintf_impl+0x6b2>
800012a2:	83cd                	srli	a5,a5,0x13
800012a4:	8b85                	andi	a5,a5,1
800012a6:	cb81                	beqz	a5,800012b6 <z_cbvprintf_impl+0x6c0>
				OUTC('0');
800012a8:	45a2                	lw	a1,8(sp)
800012aa:	03000513          	li	a0,48
800012ae:	9482                	jalr	s1
800012b0:	14054763          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
800012b4:	0d05                	addi	s10,s10,1
			if (conv->altform_0c) {
800012b6:	000c0963          	beqz	s8,800012c8 <z_cbvprintf_impl+0x6d2>
				OUTC(conv->specifier);
800012ba:	45a2                	lw	a1,8(sp)
800012bc:	04314503          	lbu	a0,67(sp)
800012c0:	9482                	jalr	s1
800012c2:	12054e63          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
800012c6:	0d05                	addi	s10,s10,1
			while (pad_len-- > 0) {
800012c8:	9bea                	add	s7,s7,s10
800012ca:	a2b5                	j	80001436 <z_cbvprintf_impl+0x840>
				len = strlen(bps);
800012cc:	8522                	mv	a0,s0
800012ce:	2e41                	jal	8000165e <strlen>
800012d0:	bf81                	j	80001220 <z_cbvprintf_impl+0x62a>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
800012d2:	57c2                	lw	a5,48(sp)
			bps = buf;
800012d4:	0820                	addi	s0,sp,24
			bpe = buf + 1;
800012d6:	01910b13          	addi	s6,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
800012da:	00f10c23          	sb	a5,24(sp)
		char sign = 0;
800012de:	4d81                	li	s11,0
		size_t nj_len = (bpe - bps);
800012e0:	4505                	li	a0,1
800012e2:	b799                	j	80001228 <z_cbvprintf_impl+0x632>
			if (conv->flag_plus) {
800012e4:	04015783          	lhu	a5,64(sp)
				sign = '+';
800012e8:	02b00d93          	li	s11,43
			if (conv->flag_plus) {
800012ec:	0087f713          	andi	a4,a5,8
800012f0:	e701                	bnez	a4,800012f8 <z_cbvprintf_impl+0x702>
			} else if (conv->flag_space) {
800012f2:	0786                	slli	a5,a5,0x1
800012f4:	0207fd93          	andi	s11,a5,32
			sint = value->sint;
800012f8:	57d2                	lw	a5,52(sp)
800012fa:	5742                	lw	a4,48(sp)
			if (sint < 0) {
800012fc:	0007dd63          	bgez	a5,80001316 <z_cbvprintf_impl+0x720>
				value->uint = (uint_value_type)-sint;
80001300:	40e006b3          	neg	a3,a4
80001304:	40f007b3          	neg	a5,a5
80001308:	00e03733          	snez	a4,a4
8000130c:	8f99                	sub	a5,a5,a4
8000130e:	d836                	sw	a3,48(sp)
80001310:	da3e                	sw	a5,52(sp)
				sign = '-';
80001312:	02d00d93          	li	s11,45
			bps = encode_uint(value->uint, conv, buf, bpe);
80001316:	5542                	lw	a0,48(sp)
80001318:	55d2                	lw	a1,52(sp)
8000131a:	02e10713          	addi	a4,sp,46
8000131e:	0834                	addi	a3,sp,24
80001320:	0090                	addi	a2,sp,64
80001322:	fa0ff0ef          	jal	ra,80000ac2 <encode_uint>
80001326:	842a                	mv	s0,a0
			if (precision >= 0) {
80001328:	020bc063          	bltz	s7,80001348 <z_cbvprintf_impl+0x752>
				conv->flag_zero = false;
8000132c:	04015703          	lhu	a4,64(sp)
				size_t len = bpe - bps;
80001330:	02e10793          	addi	a5,sp,46
80001334:	8f81                	sub	a5,a5,s0
				conv->flag_zero = false;
80001336:	fbf77713          	andi	a4,a4,-65
8000133a:	04e11023          	sh	a4,64(sp)
				if (len < (size_t)precision) {
8000133e:	0177f563          	bgeu	a5,s7,80001348 <z_cbvprintf_impl+0x752>
					conv->pad0_value = precision - (int)len;
80001342:	40fb87b3          	sub	a5,s7,a5
80001346:	c2be                	sw	a5,68(sp)
		if (bps == NULL) {
80001348:	e20403e3          	beqz	s0,8000116e <z_cbvprintf_impl+0x578>
		size_t nj_len = (bpe - bps);
8000134c:	02e10793          	addi	a5,sp,46
80001350:	40878533          	sub	a0,a5,s0
		if (sign != 0) {
80001354:	8b3e                	mv	s6,a5
80001356:	ec0d89e3          	beqz	s11,80001228 <z_cbvprintf_impl+0x632>
			nj_len += 1U;
8000135a:	0505                	addi	a0,a0,1
8000135c:	b5f1                	j	80001228 <z_cbvprintf_impl+0x632>
			if (value->ptr != NULL) {
8000135e:	5542                	lw	a0,48(sp)
80001360:	c53d                	beqz	a0,800013ce <z_cbvprintf_impl+0x7d8>
				bps = encode_uint((uintptr_t)value->ptr, conv,
80001362:	02e10b13          	addi	s6,sp,46
80001366:	875a                	mv	a4,s6
80001368:	0834                	addi	a3,sp,24
8000136a:	0090                	addi	a2,sp,64
8000136c:	4581                	li	a1,0
8000136e:	f54ff0ef          	jal	ra,80000ac2 <encode_uint>
				conv->altform_0c = true;
80001372:	04215783          	lhu	a5,66(sp)
80001376:	6721                	lui	a4,0x8
80001378:	81070713          	addi	a4,a4,-2032 # 7810 <__rom_region_size+0x4810>
8000137c:	0ef7f793          	andi	a5,a5,239
80001380:	8fd9                	or	a5,a5,a4
80001382:	04f11123          	sh	a5,66(sp)
				bps = encode_uint((uintptr_t)value->ptr, conv,
80001386:	842a                	mv	s0,a0
		char sign = 0;
80001388:	4d81                	li	s11,0
			if (precision >= 0) {
8000138a:	fa0bd1e3          	bgez	s7,8000132c <z_cbvprintf_impl+0x736>
		size_t nj_len = (bpe - bps);
8000138e:	40ab0533          	sub	a0,s6,a0
		if (bps == NULL) {
80001392:	e8041be3          	bnez	s0,80001228 <z_cbvprintf_impl+0x632>
80001396:	bbe1                	j	8000116e <z_cbvprintf_impl+0x578>
	switch ((enum length_mod_enum)conv->length_mod) {
80001398:	471d                	li	a4,7
				store_count(conv, value->ptr, count);
8000139a:	57c2                	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
8000139c:	dcd769e3          	bltu	a4,a3,8000116e <z_cbvprintf_impl+0x578>
800013a0:	80003737          	lui	a4,0x80003
800013a4:	c6470713          	addi	a4,a4,-924 # 80002c64 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002c65>
800013a8:	068a                	slli	a3,a3,0x2
800013aa:	96ba                	add	a3,a3,a4
800013ac:	4298                	lw	a4,0(a3)
800013ae:	8702                	jr	a4
		*(signed char *)dp = (signed char)count;
800013b0:	01a78023          	sb	s10,0(a5)
		if (bps == NULL) {
800013b4:	bb6d                	j	8000116e <z_cbvprintf_impl+0x578>
		*(short *)dp = (short)count;
800013b6:	01a79023          	sh	s10,0(a5)
		if (bps == NULL) {
800013ba:	bb55                	j	8000116e <z_cbvprintf_impl+0x578>
		*(intmax_t *)dp = (intmax_t)count;
800013bc:	41fd5713          	srai	a4,s10,0x1f
800013c0:	01a7a023          	sw	s10,0(a5)
800013c4:	c3d8                	sw	a4,4(a5)
		if (bps == NULL) {
800013c6:	b365                	j	8000116e <z_cbvprintf_impl+0x578>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
800013c8:	01a7a023          	sw	s10,0(a5)
		if (bps == NULL) {
800013cc:	b34d                	j	8000116e <z_cbvprintf_impl+0x578>
800013ce:	80003437          	lui	s0,0x80003
			bpe = bps + 5;
800013d2:	80003b37          	lui	s6,0x80003
800013d6:	c0440413          	addi	s0,s0,-1020 # 80002c04 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002c05>
800013da:	c09b0b13          	addi	s6,s6,-1015 # 80002c09 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002c0a>
		char sign = 0;
800013de:	4d81                	li	s11,0
		size_t nj_len = (bpe - bps);
800013e0:	4515                	li	a0,5
800013e2:	b599                	j	80001228 <z_cbvprintf_impl+0x632>
		} else if (conv->altform_0) {
800013e4:	0087f713          	andi	a4,a5,8
800013e8:	e40707e3          	beqz	a4,80001236 <z_cbvprintf_impl+0x640>
			nj_len += 1U;
800013ec:	0505                	addi	a0,a0,1
800013ee:	b5a1                	j	80001236 <z_cbvprintf_impl+0x640>
					OUTC(pad);
800013f0:	45a2                	lw	a1,8(sp)
800013f2:	853a                	mv	a0,a4
800013f4:	c63a                	sw	a4,12(sp)
800013f6:	9482                	jalr	s1
800013f8:	4732                	lw	a4,12(sp)
800013fa:	e6055fe3          	bgez	a0,80001278 <z_cbvprintf_impl+0x682>
#undef OUTS
#undef OUTC
}
800013fe:	40ba                	lw	ra,140(sp)
80001400:	442a                	lw	s0,136(sp)
80001402:	449a                	lw	s1,132(sp)
80001404:	490a                	lw	s2,128(sp)
80001406:	59f6                	lw	s3,124(sp)
80001408:	5a66                	lw	s4,120(sp)
8000140a:	5ad6                	lw	s5,116(sp)
8000140c:	5b46                	lw	s6,112(sp)
8000140e:	5bb6                	lw	s7,108(sp)
80001410:	5c26                	lw	s8,104(sp)
80001412:	5c96                	lw	s9,100(sp)
80001414:	5d06                	lw	s10,96(sp)
80001416:	4df6                	lw	s11,92(sp)
80001418:	6149                	addi	sp,sp,144
8000141a:	8082                	ret
				char pad = ' ';
8000141c:	02000713          	li	a4,32
80001420:	bd99                	j	80001276 <z_cbvprintf_impl+0x680>
					pad = '0';
80001422:	03000713          	li	a4,48
80001426:	bd81                	j	80001276 <z_cbvprintf_impl+0x680>
				OUTC('0');
80001428:	45a2                	lw	a1,8(sp)
8000142a:	03000513          	li	a0,48
8000142e:	9482                	jalr	s1
80001430:	fc0547e3          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
80001434:	0d05                	addi	s10,s10,1
			while (pad_len-- > 0) {
80001436:	41ab87b3          	sub	a5,s7,s10
8000143a:	fef047e3          	bgtz	a5,80001428 <z_cbvprintf_impl+0x832>
			OUTS(bps, bpe);
8000143e:	45a2                	lw	a1,8(sp)
80001440:	86da                	mv	a3,s6
80001442:	8622                	mv	a2,s0
80001444:	8526                	mv	a0,s1
80001446:	f66ff0ef          	jal	ra,80000bac <outs>
8000144a:	fa054ae3          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
8000144e:	9d2a                	add	s10,s10,a0
		while (width > 0) {
80001450:	9aea                	add	s5,s5,s10
80001452:	41aa87b3          	sub	a5,s5,s10
80001456:	d0f05ce3          	blez	a5,8000116e <z_cbvprintf_impl+0x578>
			OUTC(' ');
8000145a:	45a2                	lw	a1,8(sp)
8000145c:	02000513          	li	a0,32
80001460:	9482                	jalr	s1
80001462:	f8054ee3          	bltz	a0,800013fe <z_cbvprintf_impl+0x808>
80001466:	0d05                	addi	s10,s10,1
			--width;
80001468:	b7ed                	j	80001452 <z_cbvprintf_impl+0x85c>

8000146a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
8000146a:	8082                	ret

8000146c <arch_cpu_idle>:
 * This function will be called by the kernel idle loop or possibly within
 * an implementation of _pm_save_idle in the kernel when the
 * '_pm_save_flag' variable is non-zero.
 */
void arch_cpu_idle(void)
{
8000146c:	1141                	addi	sp,sp,-16
8000146e:	c606                	sw	ra,12(sp)
	sys_trace_idle();
80001470:	20a9                	jal	800014ba <sys_trace_idle>
 * use atomic instruction csrs to unlock global irq
 * csrs: atomic set bits in CSR register
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	__asm__ volatile ("csrs mstatus, %0"
80001472:	47a1                	li	a5,8
80001474:	3007a073          	csrs	mstatus,a5
	__asm__ volatile("wfi");
80001478:	10500073          	wfi
	riscv_idle(MSTATUS_IEN);
}
8000147c:	40b2                	lw	ra,12(sp)
8000147e:	0141                	addi	sp,sp,16
80001480:	8082                	ret

80001482 <arch_irq_enable>:
{
#if defined(CONFIG_3RD_LEVEL_INTERRUPTS)
	return ((irq >> 16) & 0xFF) != 0 ? 3 :
		(((irq >> 8) & 0xFF) == 0 ? 1 : 2);
#elif defined(CONFIG_2ND_LEVEL_INTERRUPTS)
	return ((irq >> 8) & 0xFF) == 0 ? 1 : 2;
80001482:	00855793          	srli	a5,a0,0x8
80001486:	0ff7f713          	zext.b	a4,a5
8000148a:	e719                	bnez	a4,80001498 <arch_irq_enable+0x16>
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
8000148c:	4785                	li	a5,1
8000148e:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
80001492:	30452573          	csrrs	a0,mie,a0
}
80001496:	8082                	ret
		riscv_plic_irq_enable(irq);
80001498:	fff78513          	addi	a0,a5,-1
8000149c:	ac6d                	j	80001756 <riscv_plic_irq_enable>

8000149e <z_riscv_irq_priority_set>:
8000149e:	8121                	srli	a0,a0,0x8
800014a0:	0ff57793          	zext.b	a5,a0
800014a4:	c399                	beqz	a5,800014aa <z_riscv_irq_priority_set+0xc>
{
	unsigned int level = irq_get_level(irq);

	if (level == 2) {
		irq = irq_from_level_2(irq);
		riscv_plic_set_priority(irq, prio);
800014a6:	157d                	addi	a0,a0,-1
800014a8:	acd1                	j	8000177c <riscv_plic_set_priority>
	}
}
800014aa:	8082                	ret

800014ac <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
800014ac:	300477f3          	csrrci	a5,mstatus,8
__weak void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)arch_irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
800014b0:	30405073          	csrwi	mie,0
800014b4:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
800014b8:	8082                	ret

800014ba <sys_trace_idle>:

void sys_trace_isr_exit(void) {}

void sys_trace_isr_exit_to_scheduler(void) {}

void sys_trace_idle(void) {}
800014ba:	8082                	ret

800014bc <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
800014bc:	1141                	addi	sp,sp,-16
800014be:	c606                	sw	ra,12(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
800014c0:	7b8000ef          	jal	ra,80001c78 <z_fatal_error>

800014c4 <_Fault>:

	return false;
}

void _Fault(z_arch_esf_t *esf)
{
800014c4:	1141                	addi	sp,sp,-16
800014c6:	c606                	sw	ra,12(sp)
800014c8:	85aa                	mv	a1,a0
	}
#endif /* CONFIG_USERSPACE */

	unsigned long mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
800014ca:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	unsigned long mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
800014ce:	343027f3          	csrr	a5,mtval
	z_fatal_error(reason, esf);
800014d2:	4501                	li	a0,0
800014d4:	7a4000ef          	jal	ra,80001c78 <z_fatal_error>

800014d8 <z_irq_spurious>:
#include <kernel_internal.h>
#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
800014d8:	1141                	addi	sp,sp,-16
800014da:	c606                	sw	ra,12(sp)
	unsigned long mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
800014dc:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
800014e0:	4581                	li	a1,0
800014e2:	4505                	li	a0,1
800014e4:	3fe1                	jal	800014bc <z_riscv_fatal_error>

800014e6 <_PrepC>:
 *
 * This routine prepares for the execution of and runs C code.
 */

void _PrepC(void)
{
800014e6:	1141                	addi	sp,sp,-16
800014e8:	c606                	sw	ra,12(sp)
	z_bss_zero();
800014ea:	7ee000ef          	jal	ra,80001cd8 <z_bss_zero>
	z_data_copy();
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
800014ee:	3f7d                	jal	800014ac <soc_interrupt_init>
#endif
	z_cstart();
800014f0:	08b000ef          	jal	ra,80001d7a <z_cstart>

800014f4 <z_riscv_secondary_cpu_init>:
}

void z_riscv_secondary_cpu_init(int cpu_num)
{
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	__asm__("mv tp, %0" : : "r" (z_idle_threads[cpu_num].tls));
800014f4:	09000713          	li	a4,144
800014f8:	02e50733          	mul	a4,a0,a4
800014fc:	800037b7          	lui	a5,0x80003
{
80001500:	1141                	addi	sp,sp,-16
	__asm__("mv tp, %0" : : "r" (z_idle_threads[cpu_num].tls));
80001502:	03878793          	addi	a5,a5,56 # 80003038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003039>
{
80001506:	c422                	sw	s0,8(sp)
80001508:	c606                	sw	ra,12(sp)
8000150a:	842a                	mv	s0,a0
	__asm__("mv tp, %0" : : "r" (z_idle_threads[cpu_num].tls));
8000150c:	97ba                	add	a5,a5,a4
8000150e:	08c7a783          	lw	a5,140(a5)
80001512:	823e                	mv	tp,a5
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
80001514:	3f61                	jal	800014ac <soc_interrupt_init>
#endif
#ifdef CONFIG_RISCV_PMP
	z_riscv_pmp_init();
80001516:	20a1                	jal	8000155e <z_riscv_pmp_init>
#endif
#ifdef CONFIG_SMP
	irq_enable(RISCV_MACHINE_SOFT_IRQ);
#endif
	riscv_cpu_init[cpu_num].fn(riscv_cpu_init[cpu_num].arg);
80001518:	800037b7          	lui	a5,0x80003
8000151c:	040e                	slli	s0,s0,0x3
8000151e:	01878793          	addi	a5,a5,24 # 80003018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003019>
80001522:	97a2                	add	a5,a5,s0
80001524:	4398                	lw	a4,0(a5)
80001526:	43c8                	lw	a0,4(a5)
80001528:	9702                	jalr	a4

8000152a <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
8000152a:	fb060613          	addi	a2,a2,-80 # 3fb0 <__rom_region_size+0xfb0>
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
8000152e:	9a41                	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (unsigned long)entry;
	stack_init->a1 = (unsigned long)p1;
	stack_init->a2 = (unsigned long)p2;
80001530:	d61c                	sw	a5,40(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
80001532:	6789                	lui	a5,0x2
80001534:	88078793          	addi	a5,a5,-1920 # 1880 <__kernel_ram_size+0x8dc>
80001538:	c27c                	sw	a5,68(a2)
		/* User thread */
		stack_init->mepc = (unsigned long)k_thread_user_mode_enter;

	} else {
		/* Supervisor thread */
		stack_init->mepc = (unsigned long)z_thread_entry;
8000153a:	800017b7          	lui	a5,0x80001
8000153e:	a9878793          	addi	a5,a5,-1384 # 80000a98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000a99>
80001542:	c23c                	sw	a5,64(a2)
#endif

	thread->callee_saved.sp = (unsigned long)stack_init;

	/* where to go when returning from z_riscv_switch() */
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
80001544:	800007b7          	lui	a5,0x80000
	stack_init->a0 = (unsigned long)entry;
80001548:	d214                	sw	a3,32(a2)
	stack_init->a1 = (unsigned long)p1;
8000154a:	d258                	sw	a4,36(a2)
	stack_init->a3 = (unsigned long)p3;
8000154c:	03062623          	sw	a6,44(a2)
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
80001550:	10678793          	addi	a5,a5,262 # 80000106 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000107>
	thread->callee_saved.sp = (unsigned long)stack_init;
80001554:	d910                	sw	a2,48(a0)
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
80001556:	d95c                	sw	a5,52(a0)

	/* our switch handle is the thread pointer itself */
	thread->switch_handle = thread;
80001558:	08a52223          	sw	a0,132(a0)
}
8000155c:	8082                	ret

8000155e <z_riscv_pmp_init>:
	unsigned long pmp_addr[4];
	unsigned long pmp_cfg[1];
	unsigned int index = 0;

	/* The read-only area is always there for every mode */
	set_pmp_entry(&index, PMP_R | PMP_X | PMP_L,
8000155e:	800007b7          	lui	a5,0x80000
80001562:	668d                	lui	a3,0x3
80001564:	00068693          	mv	a3,a3
80001568:	00078793          	mv	a5,a5
{
8000156c:	7179                	addi	sp,sp,-48
	} else if (((size  & (size - 1)) == 0) /* power of 2 */ &&
8000156e:	fff68713          	addi	a4,a3,-1 # 2fff <__kernel_ram_size+0x205b>
80001572:	00d7e633          	or	a2,a5,a3
{
80001576:	d606                	sw	ra,44(sp)
80001578:	d422                	sw	s0,40(sp)
	} else if (((size  & (size - 1)) == 0) /* power of 2 */ &&
8000157a:	8e79                	and	a2,a2,a4
8000157c:	ee31                	bnez	a2,800015d8 <z_riscv_pmp_init+0x7a>
		pmp_addr[index] = PMP_ADDR_NAPOT(start, size);
8000157e:	8305                	srli	a4,a4,0x1
80001580:	8f5d                	or	a4,a4,a5
80001582:	8309                	srli	a4,a4,0x2
80001584:	c83a                	sw	a4,16(sp)
		pmp_n_cfg[index] = perm | (size == 4 ? PMP_NA4 : PMP_NAPOT);
80001586:	4711                	li	a4,4
80001588:	47e1                	li	a5,24
8000158a:	00e69363          	bne	a3,a4,80001590 <z_riscv_pmp_init+0x32>
8000158e:	47c1                	li	a5,16
80001590:	f857e793          	ori	a5,a5,-123
80001594:	00f10623          	sb	a5,12(sp)
		index += 1;
80001598:	4405                	li	s0,1
		index += 1;
8000159a:	87a2                	mv	a5,s0
			pmp_n_cfg[index] = 0;
8000159c:	0078                	addi	a4,sp,12
8000159e:	973e                	add	a4,a4,a5
		for (index = end; index % PMPCFG_STRIDE != 0; index++) {
800015a0:	0785                	addi	a5,a5,1 # 80000001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000002>
			pmp_n_cfg[index] = 0;
800015a2:	00070023          	sb	zero,0(a4)
		for (index = end; index % PMPCFG_STRIDE != 0; index++) {
800015a6:	0037f713          	andi	a4,a5,3
800015aa:	fb6d                	bnez	a4,8000159c <z_riscv_pmp_init+0x3e>
	z_riscv_write_pmp_entries(start, CONFIG_PMP_SLOTS, false,
800015ac:	800036b7          	lui	a3,0x80003
800015b0:	c8468713          	addi	a4,a3,-892 # 80002c84 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002c85>
800015b4:	4601                	li	a2,0
800015b6:	c8468693          	addi	a3,a3,-892
800015ba:	45c1                	li	a1,16
800015bc:	4501                	li	a0,0
800015be:	af6ff0ef          	jal	ra,800008b4 <z_riscv_write_pmp_entries>
	z_riscv_write_pmp_entries(start, end, clear_trailing_entries,
800015c2:	0078                	addi	a4,sp,12
800015c4:	0814                	addi	a3,sp,16
800015c6:	85a2                	mv	a1,s0
800015c8:	4605                	li	a2,1
800015ca:	4501                	li	a0,0
800015cc:	ae8ff0ef          	jal	ra,800008b4 <z_riscv_write_pmp_entries>
	global_pmp_end_index = index;

	if (PMP_DEBUG_DUMP) {
		dump_pmp_regs("initial register dump");
	}
}
800015d0:	50b2                	lw	ra,44(sp)
800015d2:	5422                	lw	s0,40(sp)
800015d4:	6145                	addi	sp,sp,48
800015d6:	8082                	ret
		pmp_addr[index] = PMP_ADDR(start);
800015d8:	0027d713          	srli	a4,a5,0x2
		pmp_addr[index] = PMP_ADDR(start + size);
800015dc:	97b6                	add	a5,a5,a3
800015de:	8389                	srli	a5,a5,0x2
800015e0:	ca3e                	sw	a5,20(sp)
		pmp_n_cfg[index] = 0;
800015e2:	77e5                	lui	a5,0xffff9
800015e4:	d0078793          	addi	a5,a5,-768 # ffff8d00 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8d01>
		pmp_addr[index] = PMP_ADDR(start);
800015e8:	c83a                	sw	a4,16(sp)
		pmp_n_cfg[index] = 0;
800015ea:	00f11623          	sh	a5,12(sp)
		index += 1;
800015ee:	4409                	li	s0,2
800015f0:	b76d                	j	8000159a <z_riscv_pmp_init+0x3c>

800015f2 <arch_tls_stack_setup>:
#include <kernel_tls.h>
#include <zephyr/app_memory/app_memdomain.h>
#include <zephyr/sys/util.h>

size_t arch_tls_stack_setup(struct k_thread *new_thread, char *stack_ptr)
{
800015f2:	1101                	addi	sp,sp,-32
800015f4:	ca26                	sw	s1,20(sp)
 *
 * @return Total size of TLS data/bss areas
 */
static inline size_t z_tls_data_size(void)
{
	size_t tdata_size = ROUND_UP(__tdata_size, __tdata_align);
800015f6:	00100793          	li	a5,1
800015fa:	00000493          	li	s1,0
800015fe:	94be                	add	s1,s1,a5
80001600:	14fd                	addi	s1,s1,-1
80001602:	40f007b3          	neg	a5,a5
80001606:	c452                	sw	s4,8(sp)
80001608:	8cfd                	and	s1,s1,a5
8000160a:	cc22                	sw	s0,24(sp)
	size_t tbss_size = ROUND_UP(__tbss_size, __tbss_align);
8000160c:	00400793          	li	a5,4
80001610:	00400413          	li	s0,4
80001614:	943e                	add	s0,s0,a5
80001616:	147d                	addi	s0,s0,-1
80001618:	40f007b3          	neg	a5,a5
8000161c:	8c7d                	and	s0,s0,a5

	return tdata_size + tbss_size;
8000161e:	9426                	add	s0,s0,s1
80001620:	c84a                	sw	s2,16(sp)

	/*
	 * Since we are populating things backwards,
	 * setup the TLS data/bss area first.
	 */
	stack_ptr -= z_tls_data_size();
80001622:	40858933          	sub	s2,a1,s0
{
	size_t tdata_size = (size_t)__tdata_size;
	size_t tbss_size = (size_t)__tbss_size;

	/* Copy initialized data (tdata) */
	memcpy(dest, __tdata_start, tdata_size);
80001626:	800035b7          	lui	a1,0x80003
{
8000162a:	c64e                	sw	s3,12(sp)
8000162c:	00000613          	li	a2,0
80001630:	89aa                	mv	s3,a0
80001632:	ade58593          	addi	a1,a1,-1314 # 80002ade <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002adf>
80001636:	854a                	mv	a0,s2
80001638:	ce06                	sw	ra,28(sp)
8000163a:	2881                	jal	8000168a <memcpy>

	/* Clear BSS data (tbss) */
	dest += ROUND_UP(tdata_size, __tdata_align);
	memset(dest, 0, tbss_size);
8000163c:	00990533          	add	a0,s2,s1
80001640:	00400613          	li	a2,4
80001644:	4581                	li	a1,0
80001646:	2085                	jal	800016a6 <memset>

	/*
	 * Set thread TLS pointer which is used in
	 * context switch to point to TLS area.
	 */
	new_thread->tls = POINTER_TO_UINT(stack_ptr);
80001648:	0929a623          	sw	s2,140(s3)

	return z_tls_data_size();
}
8000164c:	40f2                	lw	ra,28(sp)
8000164e:	8522                	mv	a0,s0
80001650:	4462                	lw	s0,24(sp)
80001652:	44d2                	lw	s1,20(sp)
80001654:	4942                	lw	s2,16(sp)
80001656:	49b2                	lw	s3,12(sp)
80001658:	4a22                	lw	s4,8(sp)
8000165a:	6105                	addi	sp,sp,32
8000165c:	8082                	ret

8000165e <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
8000165e:	87aa                	mv	a5,a0
	size_t n = 0;
80001660:	4501                	li	a0,0

	while (*s != '\0') {
80001662:	00a78733          	add	a4,a5,a0
80001666:	00074703          	lbu	a4,0(a4)
8000166a:	e311                	bnez	a4,8000166e <strlen+0x10>
		s++;
		n++;
	}

	return n;
}
8000166c:	8082                	ret
		n++;
8000166e:	0505                	addi	a0,a0,1
80001670:	bfcd                	j	80001662 <strlen+0x4>

80001672 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
80001672:	87aa                	mv	a5,a0
	size_t n = 0;
80001674:	4501                	li	a0,0

	while (*s != '\0' && n < maxlen) {
80001676:	00a78733          	add	a4,a5,a0
8000167a:	00074703          	lbu	a4,0(a4)
8000167e:	c319                	beqz	a4,80001684 <strnlen+0x12>
80001680:	00b51363          	bne	a0,a1,80001686 <strnlen+0x14>
		s++;
		n++;
	}

	return n;
}
80001684:	8082                	ret
		n++;
80001686:	0505                	addi	a0,a0,1
80001688:	b7fd                	j	80001676 <strnlen+0x4>

8000168a <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
8000168a:	4781                	li	a5,0
8000168c:	00f61363          	bne	a2,a5,80001692 <memcpy+0x8>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
80001690:	8082                	ret
		*(d_byte++) = *(s_byte++);
80001692:	00f586b3          	add	a3,a1,a5
80001696:	0006c683          	lbu	a3,0(a3)
8000169a:	00f50733          	add	a4,a0,a5
8000169e:	0785                	addi	a5,a5,1
800016a0:	00d70023          	sb	a3,0(a4)
		n--;
800016a4:	b7e5                	j	8000168c <memcpy+0x2>

800016a6 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
800016a6:	0ff5f593          	zext.b	a1,a1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
800016aa:	962a                	add	a2,a2,a0
	unsigned char *d_byte = (unsigned char *)buf;
800016ac:	87aa                	mv	a5,a0
	while (n > 0) {
800016ae:	00c79363          	bne	a5,a2,800016b4 <memset+0xe>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
800016b2:	8082                	ret
		*(d_byte++) = c_byte;
800016b4:	0785                	addi	a5,a5,1
800016b6:	feb78fa3          	sb	a1,-1(a5)
		n--;
800016ba:	bfd5                	j	800016ae <memset+0x8>

800016bc <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
800016bc:	557d                	li	a0,-1
800016be:	8082                	ret

800016c0 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
800016c0:	800047b7          	lui	a5,0x80004
800016c4:	f8a7aa23          	sw	a0,-108(a5) # 80003f94 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f95>
}
800016c8:	8082                	ret

800016ca <plic_init>:
 * @brief Initialize the Platform Level Interrupt Controller
 *
 * @retval 0 on success.
 */
static int plic_init(const struct device *dev)
{
800016ca:	1141                	addi	sp,sp,-16
	    (volatile struct plic_regs_t *)PLIC_REG;
	int i;

	/* Ensure that all interrupts are disabled initially */
	for (i = 0; i < PLIC_EN_SIZE; i++) {
		*en = 0U;
800016cc:	0c0027b7          	lui	a5,0xc002
{
800016d0:	c606                	sw	ra,12(sp)
		*en = 0U;
800016d2:	0007a023          	sw	zero,0(a5) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb678980>
800016d6:	0007a223          	sw	zero,4(a5)
	volatile uint32_t *prio = (volatile uint32_t *)PLIC_PRIO;
800016da:	0c0007b7          	lui	a5,0xc000
		en++;
	}

	/* Set priority of each interrupt line to 0 initially */
	for (i = 0; i < PLIC_IRQS; i++) {
800016de:	0d078713          	addi	a4,a5,208 # c0000d0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb676a50>
		*prio = 0U;
800016e2:	0007a023          	sw	zero,0(a5)
		prio++;
800016e6:	0791                	addi	a5,a5,4
	for (i = 0; i < PLIC_IRQS; i++) {
800016e8:	fee79de3          	bne	a5,a4,800016e2 <plic_init+0x18>
	}

	/* Set threshold priority to 0 */
	regs->threshold_prio = 0U;
800016ec:	0c2007b7          	lui	a5,0xc200
800016f0:	0007a023          	sw	zero,0(a5) # c200000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb876980>

	/* Setup IRQ handler for PLIC driver */
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ,
800016f4:	4601                	li	a2,0
800016f6:	4581                	li	a1,0
800016f8:	452d                	li	a0,11
800016fa:	3355                	jal	8000149e <z_riscv_irq_priority_set>
		    plic_irq_handler,
		    NULL,
		    0);

	/* Enable IRQ for PLIC driver */
	irq_enable(RISCV_MACHINE_EXT_IRQ);
800016fc:	452d                	li	a0,11
800016fe:	3351                	jal	80001482 <arch_irq_enable>

	return 0;
}
80001700:	40b2                	lw	ra,12(sp)
80001702:	4501                	li	a0,0
80001704:	0141                	addi	sp,sp,16
80001706:	8082                	ret

80001708 <plic_irq_handler>:
{
80001708:	1141                	addi	sp,sp,-16
8000170a:	c226                	sw	s1,4(sp)
	irq = regs->claim_complete;
8000170c:	0c2007b7          	lui	a5,0xc200
{
80001710:	c606                	sw	ra,12(sp)
80001712:	c422                	sw	s0,8(sp)
	irq = regs->claim_complete;
80001714:	43c0                	lw	s0,4(a5)
	save_irq = irq;
80001716:	800034b7          	lui	s1,0x80003
	if (irq == 0U || irq >= PLIC_IRQS)
8000171a:	03200793          	li	a5,50
	save_irq = irq;
8000171e:	0284a023          	sw	s0,32(s1) # 80003020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003021>
	if (irq == 0U || irq >= PLIC_IRQS)
80001722:	fff40713          	addi	a4,s0,-1
80001726:	00e7f463          	bgeu	a5,a4,8000172e <plic_irq_handler+0x26>
		z_irq_spurious(NULL);
8000172a:	4501                	li	a0,0
8000172c:	3375                	jal	800014d8 <z_irq_spurious>
	irq += CONFIG_2ND_LVL_ISR_TBL_OFFSET;
8000172e:	0431                	addi	s0,s0,12
	ite->isr(ite->arg);
80001730:	800037b7          	lui	a5,0x80003
80001734:	040e                	slli	s0,s0,0x3
80001736:	8d878793          	addi	a5,a5,-1832 # 800028d8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800028d9>
8000173a:	97a2                	add	a5,a5,s0
8000173c:	43d8                	lw	a4,4(a5)
8000173e:	4388                	lw	a0,0(a5)
80001740:	9702                	jalr	a4
	regs->claim_complete = save_irq;
80001742:	0204a703          	lw	a4,32(s1)
80001746:	0c2007b7          	lui	a5,0xc200
8000174a:	c3d8                	sw	a4,4(a5)
}
8000174c:	40b2                	lw	ra,12(sp)
8000174e:	4422                	lw	s0,8(sp)
80001750:	4492                	lw	s1,4(sp)
80001752:	0141                	addi	sp,sp,16
80001754:	8082                	ret

80001756 <riscv_plic_irq_enable>:
80001756:	300476f3          	csrrci	a3,mstatus,8
	en += (irq >> 5);
8000175a:	00555793          	srli	a5,a0,0x5
8000175e:	078a                	slli	a5,a5,0x2
80001760:	0c002737          	lui	a4,0xc002
80001764:	973e                	add	a4,a4,a5
	*en |= (1 << (irq & 31));
80001766:	4310                	lw	a2,0(a4)
80001768:	4785                	li	a5,1
8000176a:	00a79533          	sll	a0,a5,a0
8000176e:	8d51                	or	a0,a0,a2
80001770:	c308                	sw	a0,0(a4)
			  :
			  : "r" (key & MSTATUS_IEN)
80001772:	0086f793          	andi	a5,a3,8
	__asm__ volatile ("csrs mstatus, %0"
80001776:	3007a073          	csrs	mstatus,a5
}
8000177a:	8082                	ret

8000177c <riscv_plic_set_priority>:
	if (priority > PLIC_MAX_PRIO)
8000177c:	479d                	li	a5,7
8000177e:	00b7f363          	bgeu	a5,a1,80001784 <riscv_plic_set_priority+0x8>
80001782:	459d                	li	a1,7
	prio += irq;
80001784:	050a                	slli	a0,a0,0x2
80001786:	0c0007b7          	lui	a5,0xc000
8000178a:	97aa                	add	a5,a5,a0
	*prio = priority;
8000178c:	c38c                	sw	a1,0(a5)
}
8000178e:	8082                	ret

80001790 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
80001790:	1141                	addi	sp,sp,-16
80001792:	c606                	sw	ra,12(sp)
80001794:	c422                	sw	s0,8(sp)
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
80001796:	80003537          	lui	a0,0x80003
8000179a:	8c050513          	addi	a0,a0,-1856 # 800028c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800028c1>
8000179e:	295d                	jal	80001c54 <z_device_is_ready>
800017a0:	57b5                	li	a5,-19

	ARG_UNUSED(arg);

	if (!device_is_ready(uart_console_dev)) {
800017a2:	c919                	beqz	a0,800017b8 <uart_console_init+0x28>
	__stdout_hook_install(console_out);
800017a4:	80001437          	lui	s0,0x80001
800017a8:	7c240513          	addi	a0,s0,1986 # 800017c2 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800017c3>
800017ac:	3f11                	jal	800016c0 <__stdout_hook_install>
	__printk_hook_install(console_out);
800017ae:	7c240513          	addi	a0,s0,1986
800017b2:	aacff0ef          	jal	ra,80000a5e <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
800017b6:	4781                	li	a5,0
}
800017b8:	40b2                	lw	ra,12(sp)
800017ba:	4422                	lw	s0,8(sp)
800017bc:	853e                	mv	a0,a5
800017be:	0141                	addi	sp,sp,16
800017c0:	8082                	ret

800017c2 <console_out>:
{
800017c2:	1141                	addi	sp,sp,-16
800017c4:	c422                	sw	s0,8(sp)
800017c6:	c226                	sw	s1,4(sp)
800017c8:	c04a                	sw	s2,0(sp)
800017ca:	800034b7          	lui	s1,0x80003
800017ce:	c606                	sw	ra,12(sp)
	if ('\n' == c) {
800017d0:	47a9                	li	a5,10
{
800017d2:	842a                	mv	s0,a0
800017d4:	8c048913          	addi	s2,s1,-1856 # 800028c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800028c1>
	if ('\n' == c) {
800017d8:	00f51963          	bne	a0,a5,800017ea <console_out+0x28>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
800017dc:	00892783          	lw	a5,8(s2)
800017e0:	45b5                	li	a1,13
800017e2:	8c048513          	addi	a0,s1,-1856
800017e6:	43dc                	lw	a5,4(a5)
800017e8:	9782                	jalr	a5
800017ea:	00892783          	lw	a5,8(s2)
800017ee:	8c048513          	addi	a0,s1,-1856
800017f2:	0ff47593          	zext.b	a1,s0
800017f6:	43dc                	lw	a5,4(a5)
800017f8:	9782                	jalr	a5
}
800017fa:	40b2                	lw	ra,12(sp)
800017fc:	8522                	mv	a0,s0
800017fe:	4422                	lw	s0,8(sp)
80001800:	4492                	lw	s1,4(sp)
80001802:	4902                	lw	s2,0(sp)
80001804:	0141                	addi	sp,sp,16
80001806:	8082                	ret

80001808 <uart_ns16550_config_get>:

#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
static int uart_ns16550_config_get(const struct device *dev,
				   struct uart_config *cfg)
{
	struct uart_ns16550_dev_data *data = dev->data;
80001808:	491c                	lw	a5,16(a0)
	cfg->stop_bits = data->uart_config.stop_bits;
	cfg->data_bits = data->uart_config.data_bits;
	cfg->flow_ctrl = data->uart_config.flow_ctrl;

	return 0;
}
8000180a:	4501                	li	a0,0
	cfg->baudrate = data->uart_config.baudrate;
8000180c:	4398                	lw	a4,0(a5)
8000180e:	c198                	sw	a4,0(a1)
	cfg->parity = data->uart_config.parity;
80001810:	0047c703          	lbu	a4,4(a5) # c000004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb676984>
80001814:	00e58223          	sb	a4,4(a1)
	cfg->stop_bits = data->uart_config.stop_bits;
80001818:	0057c703          	lbu	a4,5(a5)
8000181c:	00e582a3          	sb	a4,5(a1)
	cfg->data_bits = data->uart_config.data_bits;
80001820:	0067c703          	lbu	a4,6(a5)
80001824:	00e58323          	sb	a4,6(a1)
	cfg->flow_ctrl = data->uart_config.flow_ctrl;
80001828:	0077c783          	lbu	a5,7(a5)
8000182c:	00f583a3          	sb	a5,7(a1)
}
80001830:	8082                	ret

80001832 <uart_ns16550_poll_in>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001832:	30047773          	csrrci	a4,mstatus,8
	return DEVICE_MMIO_GET(dev);
80001836:	415c                	lw	a5,4(a0)
{
	struct uart_ns16550_dev_data *data = dev->data;
	int ret = -1;
	k_spinlock_key_t key = k_spin_lock(&data->lock);

	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
80001838:	4615                	li	a2,5
	int ret = -1;
8000183a:	557d                	li	a0,-1
	return DEVICE_MMIO_GET(dev);
8000183c:	4394                	lw	a3,0(a5)
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
8000183e:	0107c783          	lbu	a5,16(a5)
80001842:	02c787b3          	mul	a5,a5,a2
80001846:	97b6                	add	a5,a5,a3
extern "C" {
#endif

static ALWAYS_INLINE uint8_t sys_read8(mem_addr_t addr)
{
	return *(volatile uint8_t *)addr;
80001848:	0007c783          	lbu	a5,0(a5)
8000184c:	8b85                	andi	a5,a5,1
8000184e:	c791                	beqz	a5,8000185a <uart_ns16550_poll_in+0x28>
80001850:	0006c783          	lbu	a5,0(a3)
		/* got a character */
		*c = INBYTE(RDR(dev));
		ret = 0;
80001854:	4501                	li	a0,0
		*c = INBYTE(RDR(dev));
80001856:	00f58023          	sb	a5,0(a1)
	__asm__ volatile ("csrs mstatus, %0"
8000185a:	00877793          	andi	a5,a4,8
8000185e:	3007a073          	csrs	mstatus,a5
	}

	k_spin_unlock(&data->lock, key);

	return ret;
}
80001862:	8082                	ret

80001864 <uart_ns16550_poll_out>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001864:	30047773          	csrrci	a4,mstatus,8
	return DEVICE_MMIO_GET(dev);
80001868:	415c                	lw	a5,4(a0)
					   unsigned char c)
{
	struct uart_ns16550_dev_data *data = dev->data;
	k_spinlock_key_t key = k_spin_lock(&data->lock);

	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
8000186a:	4695                	li	a3,5
	return DEVICE_MMIO_GET(dev);
8000186c:	4390                	lw	a2,0(a5)
	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
8000186e:	0107c783          	lbu	a5,16(a5)
80001872:	02d787b3          	mul	a5,a5,a3
80001876:	97b2                	add	a5,a5,a2
80001878:	0007c683          	lbu	a3,0(a5)
8000187c:	0206f693          	andi	a3,a3,32
80001880:	dee5                	beqz	a3,80001878 <uart_ns16550_poll_out+0x14>
}

static ALWAYS_INLINE void sys_write8(uint8_t data, mem_addr_t addr)
{
	*(volatile uint8_t *)addr = data;
80001882:	00b60023          	sb	a1,0(a2)
	__asm__ volatile ("csrs mstatus, %0"
80001886:	00877793          	andi	a5,a4,8
8000188a:	3007a073          	csrs	mstatus,a5
	}

	OUTBYTE(THR(dev), c);

	k_spin_unlock(&data->lock, key);
}
8000188e:	8082                	ret

80001890 <uart_ns16550_err_check>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001890:	30047773          	csrrci	a4,mstatus,8
	return DEVICE_MMIO_GET(dev);
80001894:	4154                	lw	a3,4(a0)
 */
static int uart_ns16550_err_check(const struct device *dev)
{
	struct uart_ns16550_dev_data *data = dev->data;
	k_spinlock_key_t key = k_spin_lock(&data->lock);
	int check = (INBYTE(LSR(dev)) & LSR_EOB_MASK);
80001896:	4615                	li	a2,5
80001898:	0106c783          	lbu	a5,16(a3)
8000189c:	4294                	lw	a3,0(a3)
8000189e:	02c787b3          	mul	a5,a5,a2
800018a2:	97b6                	add	a5,a5,a3
	return *(volatile uint8_t *)addr;
800018a4:	0007c503          	lbu	a0,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
800018a8:	00877793          	andi	a5,a4,8
800018ac:	0ff57513          	zext.b	a0,a0
800018b0:	3007a073          	csrs	mstatus,a5
800018b4:	8979                	andi	a0,a0,30

	k_spin_unlock(&data->lock, key);

	return check >> 1;
}
800018b6:	8105                	srli	a0,a0,0x1
800018b8:	8082                	ret

800018ba <uart_ns16550_configure>:
{
800018ba:	7179                	addi	sp,sp,-48
800018bc:	d422                	sw	s0,40(sp)
800018be:	d226                	sw	s1,36(sp)
800018c0:	d606                	sw	ra,44(sp)
800018c2:	d04a                	sw	s2,32(sp)
800018c4:	ce4e                	sw	s3,28(sp)
800018c6:	cc52                	sw	s4,24(sp)
	struct uart_ns16550_dev_data * const dev_data = dev->data;
800018c8:	01052983          	lw	s3,16(a0)
	const struct uart_ns16550_device_config * const dev_cfg = dev->config;
800018cc:	00452a03          	lw	s4,4(a0)
{
800018d0:	842a                	mv	s0,a0
800018d2:	84ae                	mv	s1,a1
	uint32_t pclk = 0U;
800018d4:	c602                	sw	zero,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
800018d6:	30047973          	csrrci	s2,mstatus,8
	if (dev_cfg->sys_clk_freq != 0U) {
800018da:	004a2783          	lw	a5,4(s4)
800018de:	12078e63          	beqz	a5,80001a1a <uart_ns16550_configure+0x160>
		pclk = dev_cfg->sys_clk_freq;
800018e2:	c63e                	sw	a5,12(sp)
	set_baud_rate(dev, cfg->baudrate, pclk);
800018e4:	4090                	lw	a2,0(s1)
	if ((baud_rate != 0U) && (pclk != 0U)) {
800018e6:	c235                	beqz	a2,8000194a <uart_ns16550_configure+0x90>
	set_baud_rate(dev, cfg->baudrate, pclk);
800018e8:	47b2                	lw	a5,12(sp)
	if ((baud_rate != 0U) && (pclk != 0U)) {
800018ea:	c3a5                	beqz	a5,8000194a <uart_ns16550_configure+0x90>
		divisor = (pclk / (baud_rate << 4));
800018ec:	00461713          	slli	a4,a2,0x4
800018f0:	02e7d7b3          	divu	a5,a5,a4
	return DEVICE_MMIO_GET(dev);
800018f4:	4054                	lw	a3,4(s0)
		lcr_cache = INBYTE(LCR(dev));
800018f6:	458d                	li	a1,3
	struct uart_ns16550_dev_data * const dev_data = dev->data;
800018f8:	4808                	lw	a0,16(s0)
		lcr_cache = INBYTE(LCR(dev));
800018fa:	0106c703          	lbu	a4,16(a3)
800018fe:	4294                	lw	a3,0(a3)
80001900:	02b70733          	mul	a4,a4,a1
80001904:	9736                	add	a4,a4,a3
80001906:	00074683          	lbu	a3,0(a4) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xb678980>
8000190a:	0ff6f813          	zext.b	a6,a3
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
8000190e:	0806e693          	ori	a3,a3,128
	*(volatile uint8_t *)addr = data;
80001912:	00d70023          	sb	a3,0(a4)
	return DEVICE_MMIO_GET(dev);
80001916:	4058                	lw	a4,4(s0)
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
80001918:	0ff7f693          	zext.b	a3,a5
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
8000191c:	83a1                	srli	a5,a5,0x8
8000191e:	4318                	lw	a4,0(a4)
80001920:	0ff7f793          	zext.b	a5,a5
80001924:	00d70023          	sb	a3,0(a4)
	return DEVICE_MMIO_GET(dev);
80001928:	4054                	lw	a3,4(s0)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
8000192a:	0106c703          	lbu	a4,16(a3)
8000192e:	4294                	lw	a3,0(a3)
80001930:	9736                	add	a4,a4,a3
80001932:	00f70023          	sb	a5,0(a4)
	return DEVICE_MMIO_GET(dev);
80001936:	4058                	lw	a4,4(s0)
		OUTBYTE(LCR(dev), lcr_cache);
80001938:	01074783          	lbu	a5,16(a4)
8000193c:	4318                	lw	a4,0(a4)
8000193e:	02b787b3          	mul	a5,a5,a1
80001942:	97ba                	add	a5,a5,a4
80001944:	01078023          	sb	a6,0(a5)
		dev_data->uart_config.baudrate = baud_rate;
80001948:	c110                	sw	a2,0(a0)
	switch (cfg->data_bits) {
8000194a:	0064c683          	lbu	a3,6(s1)
8000194e:	478d                	li	a5,3
80001950:	f7a00713          	li	a4,-134
80001954:	0ad7e663          	bltu	a5,a3,80001a00 <uart_ns16550_configure+0x146>
	switch (cfg->stop_bits) {
80001958:	0054c603          	lbu	a2,5(s1)
8000195c:	4705                	li	a4,1
8000195e:	0ce60e63          	beq	a2,a4,80001a3a <uart_ns16550_configure+0x180>
80001962:	f7a00713          	li	a4,-134
80001966:	08f61d63          	bne	a2,a5,80001a00 <uart_ns16550_configure+0x146>
8000196a:	4611                	li	a2,4
	switch (cfg->parity) {
8000196c:	0044c783          	lbu	a5,4(s1)
80001970:	c799                	beqz	a5,8000197e <uart_ns16550_configure+0xc4>
80001972:	4589                	li	a1,2
80001974:	f7a00713          	li	a4,-134
80001978:	08b79463          	bne	a5,a1,80001a00 <uart_ns16550_configure+0x146>
8000197c:	47c1                	li	a5,16
	dev_data->uart_config = *cfg;
8000197e:	4098                	lw	a4,0(s1)
	OUTBYTE(LCR(dev),
80001980:	8ed1                	or	a3,a3,a2
80001982:	8fd5                	or	a5,a5,a3
	dev_data->uart_config = *cfg;
80001984:	00e9a023          	sw	a4,0(s3)
80001988:	40d8                	lw	a4,4(s1)
	OUTBYTE(LCR(dev),
8000198a:	460d                	li	a2,3
	dev_data->uart_config = *cfg;
8000198c:	00e9a223          	sw	a4,4(s3)
	return DEVICE_MMIO_GET(dev);
80001990:	4054                	lw	a3,4(s0)
	OUTBYTE(LCR(dev),
80001992:	0106c703          	lbu	a4,16(a3)
80001996:	4294                	lw	a3,0(a3)
80001998:	02c70733          	mul	a4,a4,a2
8000199c:	9736                	add	a4,a4,a3
8000199e:	00f70023          	sb	a5,0(a4)
	return DEVICE_MMIO_GET(dev);
800019a2:	4058                	lw	a4,4(s0)
	if ((INBYTE(IIR(dev)) & IIR_FE) == IIR_FE) {
800019a4:	0c000693          	li	a3,192
	OUTBYTE(MDC(dev), mdc);
800019a8:	01074783          	lbu	a5,16(a4)
800019ac:	4318                	lw	a4,0(a4)
800019ae:	078a                	slli	a5,a5,0x2
800019b0:	97ba                	add	a5,a5,a4
800019b2:	472d                	li	a4,11
800019b4:	00e78023          	sb	a4,0(a5)
	return DEVICE_MMIO_GET(dev);
800019b8:	4058                	lw	a4,4(s0)
	OUTBYTE(FCR(dev),
800019ba:	01074783          	lbu	a5,16(a4)
800019be:	4318                	lw	a4,0(a4)
800019c0:	0786                	slli	a5,a5,0x1
800019c2:	97ba                	add	a5,a5,a4
800019c4:	f8700713          	li	a4,-121
800019c8:	00e78023          	sb	a4,0(a5)
	return DEVICE_MMIO_GET(dev);
800019cc:	4058                	lw	a4,4(s0)
	if ((INBYTE(IIR(dev)) & IIR_FE) == IIR_FE) {
800019ce:	01074783          	lbu	a5,16(a4)
800019d2:	4318                	lw	a4,0(a4)
800019d4:	0786                	slli	a5,a5,0x1
800019d6:	97ba                	add	a5,a5,a4
	return *(volatile uint8_t *)addr;
800019d8:	0007c783          	lbu	a5,0(a5)
		dev_data->fifo_size = 1;
800019dc:	4705                	li	a4,1
	if ((INBYTE(IIR(dev)) & IIR_FE) == IIR_FE) {
800019de:	0c07f793          	andi	a5,a5,192
800019e2:	00d79363          	bne	a5,a3,800019e8 <uart_ns16550_configure+0x12e>
		dev_data->fifo_size = 16;
800019e6:	4741                	li	a4,16
800019e8:	00e98423          	sb	a4,8(s3)
	const struct uart_ns16550_device_config *config = dev->config;
800019ec:	405c                	lw	a5,4(s0)
	return DEVICE_MMIO_GET(dev);
800019ee:	4398                	lw	a4,0(a5)
	OUTBYTE(IER(dev), 0x00);
800019f0:	0107c783          	lbu	a5,16(a5)
800019f4:	00074683          	lbu	a3,0(a4)
800019f8:	97ba                	add	a5,a5,a4
	*(volatile uint8_t *)addr = data;
800019fa:	00078023          	sb	zero,0(a5)
	int ret = 0;
800019fe:	4701                	li	a4,0
	__asm__ volatile ("csrs mstatus, %0"
80001a00:	00897913          	andi	s2,s2,8
80001a04:	30092073          	csrs	mstatus,s2
};
80001a08:	50b2                	lw	ra,44(sp)
80001a0a:	5422                	lw	s0,40(sp)
80001a0c:	5492                	lw	s1,36(sp)
80001a0e:	5902                	lw	s2,32(sp)
80001a10:	49f2                	lw	s3,28(sp)
80001a12:	4a62                	lw	s4,24(sp)
80001a14:	853a                	mv	a0,a4
80001a16:	6145                	addi	sp,sp,48
80001a18:	8082                	ret
		if (!device_is_ready(dev_cfg->clock_dev)) {
80001a1a:	008a2503          	lw	a0,8(s4)
80001a1e:	2c1d                	jal	80001c54 <z_device_is_ready>
			ret = -EINVAL;
80001a20:	5729                	li	a4,-22
		if (!device_is_ready(dev_cfg->clock_dev)) {
80001a22:	dd79                	beqz	a0,80001a00 <uart_ns16550_configure+0x146>
		clock_control_get_rate(dev_cfg->clock_dev, dev_cfg->clock_subsys,
80001a24:	008a2503          	lw	a0,8(s4)
80001a28:	00ca2583          	lw	a1,12(s4)
					 uint32_t *rate)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->api;

	if (api->get_rate == NULL) {
80001a2c:	451c                	lw	a5,8(a0)
80001a2e:	47dc                	lw	a5,12(a5)
80001a30:	ea078ae3          	beqz	a5,800018e4 <uart_ns16550_configure+0x2a>
		return -ENOSYS;
	}

	return api->get_rate(dev, sys, rate);
80001a34:	0070                	addi	a2,sp,12
80001a36:	9782                	jalr	a5
80001a38:	b575                	j	800018e4 <uart_ns16550_configure+0x2a>
		uart_cfg.stop_bits = LCR_1_STB;
80001a3a:	4601                	li	a2,0
80001a3c:	bf05                	j	8000196c <uart_ns16550_configure+0xb2>

80001a3e <uart_ns16550_init>:
	ret = uart_ns16550_configure(dev, &data->uart_config);
80001a3e:	490c                	lw	a1,16(a0)
80001a40:	bdad                	j	800018ba <uart_ns16550_configure>

80001a42 <mtime>:
	volatile uint32_t *r = (uint32_t *)MTIME_REG;
	uint32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
80001a42:	0200c737          	lui	a4,0x200c
80001a46:	ffc70793          	addi	a5,a4,-4 # 200bffc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x168297c>
		lo = r[0];
80001a4a:	ff870613          	addi	a2,a4,-8
		hi = r[1];
80001a4e:	4394                	lw	a3,0(a5)
		lo = r[0];
80001a50:	4208                	lw	a0,0(a2)
	} while (r[1] != hi);
80001a52:	438c                	lw	a1,0(a5)
80001a54:	fed599e3          	bne	a1,a3,80001a46 <mtime+0x4>

	return (((uint64_t)hi) << 32) | lo;
#endif
}
80001a58:	8082                	ret

80001a5a <sys_clock_driver_init>:
{
	return (mtime() << CONFIG_RISCV_MACHINE_TIMER_SYSTEM_CLOCK_DIVIDER);
}

static int sys_clock_driver_init(const struct device *dev)
{
80001a5a:	1141                	addi	sp,sp,-16
	ARG_UNUSED(dev);

	IRQ_CONNECT(TIMER_IRQN, 0, timer_isr, NULL, 0);
80001a5c:	4601                	li	a2,0
80001a5e:	4581                	li	a1,0
80001a60:	451d                	li	a0,7
{
80001a62:	c606                	sw	ra,12(sp)
	IRQ_CONNECT(TIMER_IRQN, 0, timer_isr, NULL, 0);
80001a64:	3c2d                	jal	8000149e <z_riscv_irq_priority_set>
	last_count = mtime();
80001a66:	3ff1                	jal	80001a42 <mtime>
80001a68:	800037b7          	lui	a5,0x80003
80001a6c:	00a7a023          	sw	a0,0(a5) # 80003000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003001>
80001a70:	00b7a223          	sw	a1,4(a5)
	return MTIMECMP_REG + (_current_cpu->id * 8);
80001a74:	800037b7          	lui	a5,0x80003
80001a78:	16c7c783          	lbu	a5,364(a5) # 8000316c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000316d>
	set_mtimecmp(last_count + CYC_PER_TICK);
80001a7c:	6761                	lui	a4,0x18
	return MTIMECMP_REG + (_current_cpu->id * 8);
80001a7e:	020046b7          	lui	a3,0x2004
	set_mtimecmp(last_count + CYC_PER_TICK);
80001a82:	6a070713          	addi	a4,a4,1696 # 186a0 <__rom_region_size+0x156a0>
	return MTIMECMP_REG + (_current_cpu->id * 8);
80001a86:	078e                	slli	a5,a5,0x3
80001a88:	97b6                	add	a5,a5,a3
	set_mtimecmp(last_count + CYC_PER_TICK);
80001a8a:	972a                	add	a4,a4,a0
	r[1] = 0xffffffff;
80001a8c:	56fd                	li	a3,-1
	set_mtimecmp(last_count + CYC_PER_TICK);
80001a8e:	00a73533          	sltu	a0,a4,a0
	r[1] = 0xffffffff;
80001a92:	c3d4                	sw	a3,4(a5)
	set_mtimecmp(last_count + CYC_PER_TICK);
80001a94:	95aa                	add	a1,a1,a0
	r[0] = (uint32_t)time;
80001a96:	c398                	sw	a4,0(a5)
	irq_enable(TIMER_IRQN);
80001a98:	451d                	li	a0,7
	r[1] = (uint32_t)(time >> 32);
80001a9a:	c3cc                	sw	a1,4(a5)
	irq_enable(TIMER_IRQN);
80001a9c:	32dd                	jal	80001482 <arch_irq_enable>
	return 0;
}
80001a9e:	40b2                	lw	ra,12(sp)
80001aa0:	4501                	li	a0,0
80001aa2:	0141                	addi	sp,sp,16
80001aa4:	8082                	ret

80001aa6 <timer_isr>:
{
80001aa6:	1101                	addi	sp,sp,-32
80001aa8:	ce06                	sw	ra,28(sp)
80001aaa:	cc22                	sw	s0,24(sp)
80001aac:	ca26                	sw	s1,20(sp)
80001aae:	c84a                	sw	s2,16(sp)
80001ab0:	c64e                	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001ab2:	300479f3          	csrrci	s3,mstatus,8
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
80001ab6:	800034b7          	lui	s1,0x80003
	uint64_t now = mtime();
80001aba:	3761                	jal	80001a42 <mtime>
80001abc:	842a                	mv	s0,a0
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
80001abe:	0004a503          	lw	a0,0(s1) # 80003000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003001>
80001ac2:	0044a783          	lw	a5,4(s1)
	uint64_t now = mtime();
80001ac6:	892e                	mv	s2,a1
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
80001ac8:	40a40533          	sub	a0,s0,a0
80001acc:	00a435b3          	sltu	a1,s0,a0
80001ad0:	40f907b3          	sub	a5,s2,a5
80001ad4:	6661                	lui	a2,0x18
80001ad6:	6a060613          	addi	a2,a2,1696 # 186a0 <__rom_region_size+0x156a0>
80001ada:	4681                	li	a3,0
80001adc:	40b785b3          	sub	a1,a5,a1
80001ae0:	e84fe0ef          	jal	ra,80000164 <__udivdi3>
	__asm__ volatile ("csrs mstatus, %0"
80001ae4:	0089f993          	andi	s3,s3,8
	last_count = now;
80001ae8:	0084a023          	sw	s0,0(s1)
80001aec:	0124a223          	sw	s2,4(s1)
80001af0:	3009a073          	csrs	mstatus,s3
}
80001af4:	4462                	lw	s0,24(sp)
80001af6:	40f2                	lw	ra,28(sp)
80001af8:	44d2                	lw	s1,20(sp)
80001afa:	4942                	lw	s2,16(sp)
80001afc:	49b2                	lw	s3,12(sp)
80001afe:	6105                	addi	sp,sp,32
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
80001b00:	4af0006f          	j	800027ae <sys_clock_announce>

80001b04 <sys_clock_set_timeout>:
	if (idle) {
80001b04:	e5dd                	bnez	a1,80001bb2 <sys_clock_set_timeout+0xae>
{
80001b06:	1141                	addi	sp,sp,-16
80001b08:	c606                	sw	ra,12(sp)
80001b0a:	c422                	sw	s0,8(sp)
80001b0c:	c226                	sw	s1,4(sp)
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
80001b0e:	57fd                	li	a5,-1
80001b10:	08f50d63          	beq	a0,a5,80001baa <sys_clock_set_timeout+0xa6>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
80001b14:	4785                	li	a5,1
80001b16:	4401                	li	s0,0
80001b18:	00a7d963          	bge	a5,a0,80001b2a <sys_clock_set_timeout+0x26>
80001b1c:	6415                	lui	s0,0x5
80001b1e:	3e140413          	addi	s0,s0,993 # 53e1 <__rom_region_size+0x23e1>
80001b22:	00a44463          	blt	s0,a0,80001b2a <sys_clock_set_timeout+0x26>
80001b26:	fff50413          	addi	s0,a0,-1
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001b2a:	300474f3          	csrrci	s1,mstatus,8
	uint64_t now = mtime();
80001b2e:	3f11                	jal	80001a42 <mtime>
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
80001b30:	6761                	lui	a4,0x18
80001b32:	6a070613          	addi	a2,a4,1696 # 186a0 <__rom_region_size+0x156a0>
80001b36:	02c40433          	mul	s0,s0,a2
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
80001b3a:	800037b7          	lui	a5,0x80003
80001b3e:	0007a683          	lw	a3,0(a5) # 80003000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003001>
80001b42:	69f70713          	addi	a4,a4,1695
80001b46:	0047a583          	lw	a1,4(a5)
80001b4a:	8f15                	sub	a4,a4,a3
	if (cyc <= MAX_CYC - adj) {
80001b4c:	800007b7          	lui	a5,0x80000
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
80001b50:	972a                	add	a4,a4,a0
	if (cyc <= MAX_CYC - adj) {
80001b52:	fff7c793          	not	a5,a5
80001b56:	40e78833          	sub	a6,a5,a4
80001b5a:	00886463          	bltu	a6,s0,80001b62 <sys_clock_set_timeout+0x5e>
		cyc += adj;
80001b5e:	00e407b3          	add	a5,s0,a4
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
80001b62:	02c7d7b3          	divu	a5,a5,a2
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
80001b66:	40a68533          	sub	a0,a3,a0
80001b6a:	06300713          	li	a4,99
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
80001b6e:	02c787b3          	mul	a5,a5,a2
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
80001b72:	953e                	add	a0,a0,a5
80001b74:	00a74363          	blt	a4,a0,80001b7a <sys_clock_set_timeout+0x76>
		cyc += CYC_PER_TICK;
80001b78:	97b2                	add	a5,a5,a2
	return MTIMECMP_REG + (_current_cpu->id * 8);
80001b7a:	80003737          	lui	a4,0x80003
80001b7e:	16c74703          	lbu	a4,364(a4) # 8000316c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000316d>
80001b82:	02004637          	lui	a2,0x2004
	set_mtimecmp(cyc + last_count);
80001b86:	96be                	add	a3,a3,a5
	return MTIMECMP_REG + (_current_cpu->id * 8);
80001b88:	070e                	slli	a4,a4,0x3
80001b8a:	9732                	add	a4,a4,a2
	r[1] = 0xffffffff;
80001b8c:	567d                	li	a2,-1
80001b8e:	c350                	sw	a2,4(a4)
	set_mtimecmp(cyc + last_count);
80001b90:	00f6b7b3          	sltu	a5,a3,a5
80001b94:	97ae                	add	a5,a5,a1
	r[0] = (uint32_t)time;
80001b96:	c314                	sw	a3,0(a4)
	r[1] = (uint32_t)(time >> 32);
80001b98:	c35c                	sw	a5,4(a4)
	__asm__ volatile ("csrs mstatus, %0"
80001b9a:	88a1                	andi	s1,s1,8
80001b9c:	3004a073          	csrs	mstatus,s1
}
80001ba0:	40b2                	lw	ra,12(sp)
80001ba2:	4422                	lw	s0,8(sp)
80001ba4:	4492                	lw	s1,4(sp)
80001ba6:	0141                	addi	sp,sp,16
80001ba8:	8082                	ret
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
80001baa:	6515                	lui	a0,0x5
80001bac:	3e150513          	addi	a0,a0,993 # 53e1 <__rom_region_size+0x23e1>
80001bb0:	bf9d                	j	80001b26 <sys_clock_set_timeout+0x22>
80001bb2:	8082                	ret

80001bb4 <sys_clock_elapsed>:
{
80001bb4:	1141                	addi	sp,sp,-16
80001bb6:	c606                	sw	ra,12(sp)
80001bb8:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001bba:	30047473          	csrrci	s0,mstatus,8
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;
80001bbe:	3551                	jal	80001a42 <mtime>
80001bc0:	800037b7          	lui	a5,0x80003
80001bc4:	0007a783          	lw	a5,0(a5) # 80003000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003001>
	__asm__ volatile ("csrs mstatus, %0"
80001bc8:	8821                	andi	s0,s0,8
80001bca:	8d1d                	sub	a0,a0,a5
80001bcc:	67e1                	lui	a5,0x18
80001bce:	6a078793          	addi	a5,a5,1696 # 186a0 <__rom_region_size+0x156a0>
80001bd2:	02f55533          	divu	a0,a0,a5
80001bd6:	30042073          	csrs	mstatus,s0
}
80001bda:	40b2                	lw	ra,12(sp)
80001bdc:	4422                	lw	s0,8(sp)
80001bde:	0141                	addi	sp,sp,16
80001be0:	8082                	ret

80001be2 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
80001be2:	8082                	ret

80001be4 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
80001be4:	00251713          	slli	a4,a0,0x2
80001be8:	800037b7          	lui	a5,0x80003
80001bec:	0505                	addi	a0,a0,1
80001bee:	cfc78793          	addi	a5,a5,-772 # 80002cfc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002cfd>
80001bf2:	050a                	slli	a0,a0,0x2
{
80001bf4:	1101                	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
80001bf6:	973e                	add	a4,a4,a5
80001bf8:	97aa                	add	a5,a5,a0
{
80001bfa:	cc22                	sw	s0,24(sp)
80001bfc:	c84a                	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
80001bfe:	4300                	lw	s0,0(a4)
80001c00:	0007a903          	lw	s2,0(a5)
{
80001c04:	c64e                	sw	s3,12(sp)
80001c06:	ce06                	sw	ra,28(sp)
80001c08:	ca26                	sw	s1,20(sp)
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
80001c0a:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
80001c0e:	01246963          	bltu	s0,s2,80001c20 <z_sys_init_run_level+0x3c>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
80001c12:	40f2                	lw	ra,28(sp)
80001c14:	4462                	lw	s0,24(sp)
80001c16:	44d2                	lw	s1,20(sp)
80001c18:	4942                	lw	s2,16(sp)
80001c1a:	49b2                	lw	s3,12(sp)
80001c1c:	6105                	addi	sp,sp,32
80001c1e:	8082                	ret
		const struct device *dev = entry->dev;
80001c20:	4044                	lw	s1,4(s0)
		int rc = entry->init(dev);
80001c22:	401c                	lw	a5,0(s0)
80001c24:	8526                	mv	a0,s1
80001c26:	9782                	jalr	a5
		if (dev != NULL) {
80001c28:	c485                	beqz	s1,80001c50 <z_sys_init_run_level+0x6c>
			if (rc != 0) {
80001c2a:	cd01                	beqz	a0,80001c42 <z_sys_init_run_level+0x5e>
				if (rc < 0) {
80001c2c:	41f55793          	srai	a5,a0,0x1f
80001c30:	8d3d                	xor	a0,a0,a5
80001c32:	8d1d                	sub	a0,a0,a5
				dev->state->init_res = rc;
80001c34:	44d8                	lw	a4,12(s1)
				if (rc > UINT8_MAX) {
80001c36:	00a9d463          	bge	s3,a0,80001c3e <z_sys_init_run_level+0x5a>
80001c3a:	0ff00513          	li	a0,255
				dev->state->init_res = rc;
80001c3e:	00a70023          	sb	a0,0(a4)
			dev->state->initialized = true;
80001c42:	44d8                	lw	a4,12(s1)
80001c44:	00075783          	lhu	a5,0(a4)
80001c48:	1007e793          	ori	a5,a5,256
80001c4c:	00f71023          	sh	a5,0(a4)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
80001c50:	0421                	addi	s0,s0,8
80001c52:	bf75                	j	80001c0e <z_sys_init_run_level+0x2a>

80001c54 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
80001c54:	c911                	beqz	a0,80001c68 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
80001c56:	455c                	lw	a5,12(a0)
80001c58:	4388                	lw	a0,0(a5)
80001c5a:	1ff57513          	andi	a0,a0,511
80001c5e:	f0050513          	addi	a0,a0,-256
80001c62:	00153513          	seqz	a0,a0
80001c66:	8082                	ret
		return false;
80001c68:	4501                	li	a0,0
}
80001c6a:	8082                	ret

80001c6c <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001c6c:	300477f3          	csrrci	a5,mstatus,8
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
80001c70:	a001                	j	80001c70 <arch_system_halt+0x4>

80001c72 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
80001c72:	1141                	addi	sp,sp,-16
80001c74:	c606                	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
80001c76:	3fdd                	jal	80001c6c <arch_system_halt>

80001c78 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
80001c78:	1141                	addi	sp,sp,-16
80001c7a:	c606                	sw	ra,12(sp)
80001c7c:	c422                	sw	s0,8(sp)
80001c7e:	c226                	sw	s1,4(sp)
80001c80:	30047473          	csrrci	s0,mstatus,8
80001c84:	00022483          	lw	s1,0(tp) # 0 <CONFIG_2ND_LVL_INTR_01_OFFSET>
			  : "r" (key & MSTATUS_IEN)
80001c88:	8821                	andi	s0,s0,8

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
80001c8a:	37e5                	jal	80001c72 <k_sys_fatal_error_handler>
	__asm__ volatile ("csrs mstatus, %0"
80001c8c:	30042073          	csrs	mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
80001c90:	4422                	lw	s0,8(sp)
80001c92:	40b2                	lw	ra,12(sp)
80001c94:	8526                	mv	a0,s1
80001c96:	4492                	lw	s1,4(sp)
80001c98:	0141                	addi	sp,sp,16
80001c9a:	0d70006f          	j	80002570 <z_impl_k_thread_abort>

80001c9e <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
80001c9e:	1141                	addi	sp,sp,-16
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
80001ca0:	800037b7          	lui	a5,0x80003
80001ca4:	4705                	li	a4,1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
80001ca6:	4509                	li	a0,2
{
80001ca8:	c606                	sw	ra,12(sp)
	z_sys_post_kernel = true;
80001caa:	02e78823          	sb	a4,48(a5) # 80003030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003031>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
80001cae:	3f1d                	jal	80001be4 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
80001cb0:	3d3000ef          	jal	ra,80002882 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
80001cb4:	450d                	li	a0,3
80001cb6:	373d                	jal	80001be4 <z_sys_init_run_level>

	z_init_static_threads();
80001cb8:	24b1                	jal	80001f04 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
80001cba:	d85fe0ef          	jal	ra,80000a3e <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
80001cbe:	800037b7          	lui	a5,0x80003
80001cc2:	0c878793          	addi	a5,a5,200 # 800030c8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800030c9>
80001cc6:	00c7c703          	lbu	a4,12(a5)
80001cca:	9b79                	andi	a4,a4,-2
80001ccc:	00e78623          	sb	a4,12(a5)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
80001cd0:	40b2                	lw	ra,12(sp)
80001cd2:	0141                	addi	sp,sp,16
80001cd4:	8082                	ret

80001cd6 <z_early_memset>:
	(void) memset(dst, c, n);
80001cd6:	bac1                	j	800016a6 <memset>

80001cd8 <z_bss_zero>:
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
80001cd8:	80003537          	lui	a0,0x80003
80001cdc:	800037b7          	lui	a5,0x80003
80001ce0:	00050613          	mv	a2,a0
80001ce4:	17c78793          	addi	a5,a5,380 # 8000317c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000317d>
80001ce8:	40c78633          	sub	a2,a5,a2
80001cec:	4581                	li	a1,0
80001cee:	00050513          	mv	a0,a0
80001cf2:	b7d5                	j	80001cd6 <z_early_memset>

80001cf4 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
80001cf4:	1101                	addi	sp,sp,-32
80001cf6:	c84a                	sw	s2,16(sp)
	struct k_thread *thread = &z_idle_threads[i];
80001cf8:	09000913          	li	s2,144
80001cfc:	03250933          	mul	s2,a0,s2
{
80001d00:	ca26                	sw	s1,20(sp)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
80001d02:	44e1                	li	s1,24
	struct k_thread *thread = &z_idle_threads[i];
80001d04:	800037b7          	lui	a5,0x80003
80001d08:	03878793          	addi	a5,a5,56 # 80003038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003039>
	z_setup_new_thread(thread, stack,
80001d0c:	800045b7          	lui	a1,0x80004
{
80001d10:	cc22                	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
80001d12:	800026b7          	lui	a3,0x80002
{
80001d16:	842a                	mv	s0,a0
	z_setup_new_thread(thread, stack,
80001d18:	98058593          	addi	a1,a1,-1664 # 80003980 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003981>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
80001d1c:	029504b3          	mul	s1,a0,s1
	struct k_thread *thread = &z_idle_threads[i];
80001d20:	993e                	add	s2,s2,a5
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
80001d22:	800037b7          	lui	a5,0x80003
80001d26:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
	k_thread_stack_t *stack = z_idle_stacks[i];
80001d2a:	0526                	slli	a0,a0,0x9
	z_setup_new_thread(thread, stack,
80001d2c:	c202                	sw	zero,4(sp)
80001d2e:	95aa                	add	a1,a1,a0
80001d30:	48bd                	li	a7,15
80001d32:	854a                	mv	a0,s2
80001d34:	4801                	li	a6,0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
80001d36:	94be                	add	s1,s1,a5
	z_setup_new_thread(thread, stack,
80001d38:	4785                	li	a5,1
80001d3a:	c03e                	sw	a5,0(sp)
80001d3c:	8726                	mv	a4,s1
80001d3e:	4781                	li	a5,0
80001d40:	fba68693          	addi	a3,a3,-70 # 80001fba <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001fbb>
80001d44:	20000613          	li	a2,512
{
80001d48:	ce06                	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
80001d4a:	2a21                	jal	80001e62 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
80001d4c:	00d94783          	lbu	a5,13(s2)
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
80001d50:	00848a23          	sb	s0,20(s1)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
80001d54:	0405                	addi	s0,s0,1
80001d56:	9bed                	andi	a5,a5,-5
80001d58:	00f906a3          	sb	a5,13(s2)
80001d5c:	800037b7          	lui	a5,0x80003
80001d60:	042e                	slli	s0,s0,0xb
80001d62:	18078793          	addi	a5,a5,384 # 80003180 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003181>
80001d66:	943e                	add	s0,s0,a5
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
80001d68:	0124a623          	sw	s2,12(s1)
	_kernel.cpus[id].irq_stack =
80001d6c:	c0c0                	sw	s0,4(s1)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
80001d6e:	40f2                	lw	ra,28(sp)
80001d70:	4462                	lw	s0,24(sp)
80001d72:	44d2                	lw	s1,20(sp)
80001d74:	4942                	lw	s2,16(sp)
80001d76:	6105                	addi	sp,sp,32
80001d78:	8082                	ret

80001d7a <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
80001d7a:	7131                	addi	sp,sp,-192
80001d7c:	df06                	sw	ra,188(sp)
80001d7e:	dd22                	sw	s0,184(sp)
80001d80:	db26                	sw	s1,180(sp)
80001d82:	d94a                	sw	s2,176(sp)
80001d84:	d74e                	sw	s3,172(sp)
#ifndef _ASMLANGUAGE

static ALWAYS_INLINE void arch_kernel_init(void)
{
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	__asm__ volatile ("li tp, 0");
80001d86:	4201                	li	tp,0
#endif
#ifdef CONFIG_USERSPACE
	csr_write(mscratch, 0);
#endif
#ifdef CONFIG_RISCV_PMP
	z_riscv_pmp_init();
80001d88:	fd6ff0ef          	jal	ra,8000155e <z_riscv_pmp_init>
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
80001d8c:	10100793          	li	a5,257

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
80001d90:	80003437          	lui	s0,0x80003
	dummy_thread->base.user_options = K_ESSENTIAL;
80001d94:	00f11e23          	sh	a5,28(sp)
	_current_cpu->current = dummy_thread;
80001d98:	15840413          	addi	s0,s0,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80001d9c:	081c                	addi	a5,sp,16
80001d9e:	c41c                	sw	a5,8(s0)
	dummy_thread->stack_info.start = 0U;
80001da0:	c302                	sw	zero,132(sp)
	dummy_thread->stack_info.size = 0U;
80001da2:	c502                	sw	zero,136(sp)
	dummy_thread->resource_pool = NULL;
80001da4:	cd02                	sw	zero,152(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
80001da6:	3d35                	jal	80001be2 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
80001da8:	4501                	li	a0,0
80001daa:	3d2d                	jal	80001be4 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
80001dac:	4505                	li	a0,1
80001dae:	3d1d                	jal	80001be4 <z_sys_init_run_level>
	z_sched_init();
80001db0:	2dd9                	jal	80002486 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
80001db2:	800037b7          	lui	a5,0x80003
80001db6:	d1078793          	addi	a5,a5,-752 # 80002d10 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002d11>
	_kernel.ready_q.cache = &z_main_thread;
80001dba:	800034b7          	lui	s1,0x80003
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
80001dbe:	c23e                	sw	a5,4(sp)
80001dc0:	800026b7          	lui	a3,0x80002
80001dc4:	4785                	li	a5,1
80001dc6:	800045b7          	lui	a1,0x80004
	_kernel.ready_q.cache = &z_main_thread;
80001dca:	0c848913          	addi	s2,s1,200 # 800030c8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800030c9>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
80001dce:	4881                	li	a7,0
80001dd0:	4801                	li	a6,0
80001dd2:	4701                	li	a4,0
80001dd4:	c9e68693          	addi	a3,a3,-866 # 80001c9e <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001c9f>
80001dd8:	40000613          	li	a2,1024
80001ddc:	b8058593          	addi	a1,a1,-1152 # 80003b80 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003b81>
80001de0:	c03e                	sw	a5,0(sp)
80001de2:	0c848513          	addi	a0,s1,200
80001de6:	4781                	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
80001de8:	01242c23          	sw	s2,24(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
80001dec:	289d                	jal	80001e62 <z_setup_new_thread>
80001dee:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
80001df2:	0c848513          	addi	a0,s1,200
80001df6:	9bed                	andi	a5,a5,-5
80001df8:	00f906a3          	sb	a5,13(s2)
80001dfc:	2b9d                	jal	80002372 <z_ready_thread>
	z_init_cpu(0);
80001dfe:	4501                	li	a0,0
80001e00:	3dd5                	jal	80001cf4 <z_init_cpu>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001e02:	30047973          	csrrci	s2,mstatus,8
	old_thread = _current;
80001e06:	00842983          	lw	s3,8(s0)
	z_check_stack_sentinel();
80001e0a:	202d                	jal	80001e34 <z_check_stack_sentinel>
	old_thread->swap_retval = -EAGAIN;
80001e0c:	57d5                	li	a5,-11
80001e0e:	08f9a023          	sw	a5,128(s3)
80001e12:	300477f3          	csrrci	a5,mstatus,8
	new_thread = z_swap_next_thread();
80001e16:	2d2d                	jal	80002450 <z_swap_next_thread>
	if (new_thread != old_thread) {
80001e18:	00a98a63          	beq	s3,a0,80001e2c <z_cstart+0xb2>
80001e1c:	84aa                	mv	s1,a0
		_current_cpu->current = new_thread;
80001e1e:	c408                	sw	a0,8(s0)
		z_reset_time_slice(new_thread);
80001e20:	2ae9                	jal	80001ffa <z_reset_time_slice>
	struct k_thread *old = CONTAINER_OF(switched_from, struct k_thread,
					    switch_handle);
#ifdef CONFIG_RISCV_ALWAYS_SWITCH_THROUGH_ECALL
	arch_syscall_invoke2((uintptr_t)new, (uintptr_t)old, RV_ECALL_SCHEDULE);
#else
	z_riscv_switch(new, old);
80001e22:	0844a503          	lw	a0,132(s1)
80001e26:	85ce                	mv	a1,s3
80001e28:	a19fe0ef          	jal	ra,80000840 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
80001e2c:	00897913          	andi	s2,s2,8
	__asm__ volatile ("csrs mstatus, %0"
80001e30:	30092073          	csrs	mstatus,s2

80001e34 <z_check_stack_sentinel>:
 */
void z_check_stack_sentinel(void)
{
	uint32_t *stack;

	if ((_current->base.thread_state & _THREAD_DUMMY) != 0) {
80001e34:	800037b7          	lui	a5,0x80003
80001e38:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80001e3c:	4798                	lw	a4,8(a5)
80001e3e:	00d74783          	lbu	a5,13(a4)
80001e42:	8b85                	andi	a5,a5,1
80001e44:	ef91                	bnez	a5,80001e60 <z_check_stack_sentinel+0x2c>
		return;
	}

	stack = (uint32_t *)_current->stack_info.start;
80001e46:	5b78                	lw	a4,116(a4)
	if (*stack != STACK_SENTINEL) {
80001e48:	f0f0f7b7          	lui	a5,0xf0f0f
80001e4c:	0f078793          	addi	a5,a5,240 # f0f0f0f0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0f0f0f1>
80001e50:	4314                	lw	a3,0(a4)
80001e52:	00f68763          	beq	a3,a5,80001e60 <z_check_stack_sentinel+0x2c>
		/* Restore it so further checks don't trigger this same error */
		*stack = STACK_SENTINEL;
80001e56:	c31c                	sw	a5,0(a4)
	return a0;
}

static inline uintptr_t arch_syscall_invoke1(uintptr_t arg1, uintptr_t call_id)
{
	register unsigned long a0 __asm__ ("a0") = arg1;
80001e58:	4509                	li	a0,2
	register unsigned long t0 __asm__ ("t0") = call_id;
80001e5a:	4281                	li	t0,0

	__asm__ volatile ("ecall"
80001e5c:	00000073          	ecall
		z_except_reason(K_ERR_STACK_CHK_FAIL);
	}
}
80001e60:	8082                	ret

80001e62 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
80001e62:	7179                	addi	sp,sp,-48
80001e64:	d606                	sw	ra,44(sp)
80001e66:	d422                	sw	s0,40(sp)
80001e68:	d226                	sw	s1,36(sp)
80001e6a:	d04a                	sw	s2,32(sp)
80001e6c:	ce4e                	sw	s3,28(sp)
80001e6e:	84ae                	mv	s1,a1
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
80001e70:	06c50593          	addi	a1,a0,108 # 8000306c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000306d>
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
80001e74:	d56c                	sw	a1,108(a0)
	list->tail = (sys_dnode_t *)list;
80001e76:	d92c                	sw	a1,112(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
80001e78:	55c2                	lw	a1,48(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
80001e7a:	063d                	addi	a2,a2,15 # 200400f <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x167a98f>
80001e7c:	ff067913          	andi	s2,a2,-16
	thread_base->user_options = (uint8_t)options;
80001e80:	00b50623          	sb	a1,12(a0)
	*((uint32_t *)stack_buf_start) = STACK_SENTINEL;
80001e84:	f0f0f637          	lui	a2,0xf0f0f
	thread_base->thread_state = (uint8_t)initial_state;
80001e88:	4591                	li	a1,4
	stack_ptr = (char *)stack + stack_obj_size;
80001e8a:	012489b3          	add	s3,s1,s2
	thread_base->thread_state = (uint8_t)initial_state;
80001e8e:	00b506a3          	sb	a1,13(a0)

	thread_base->prio = priority;
80001e92:	01150723          	sb	a7,14(a0)
	*((uint32_t *)stack_buf_start) = STACK_SENTINEL;
80001e96:	0f060613          	addi	a2,a2,240 # f0f0f0f0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0f0f0f1>
	thread_base->pended_on = NULL;
80001e9a:	00052423          	sw	zero,8(a0)

	thread_base->sched_locked = 0U;
80001e9e:	000507a3          	sb	zero,15(a0)
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
80001ea2:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
80001ea6:	00052e23          	sw	zero,28(a0)
	*((uint32_t *)stack_buf_start) = STACK_SENTINEL;
80001eaa:	c090                	sw	a2,0(s1)
	delta += arch_tls_stack_setup(new_thread, stack_ptr);
80001eac:	85ce                	mv	a1,s3
{
80001eae:	842a                	mv	s0,a0
80001eb0:	c636                	sw	a3,12(sp)
80001eb2:	c43a                	sw	a4,8(sp)
80001eb4:	c23e                	sw	a5,4(sp)
80001eb6:	c042                	sw	a6,0(sp)
	delta += arch_tls_stack_setup(new_thread, stack_ptr);
80001eb8:	f3aff0ef          	jal	ra,800015f2 <arch_tls_stack_setup>
	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
80001ebc:	053d                	addi	a0,a0,15
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
80001ebe:	4792                	lw	a5,4(sp)
	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
80001ec0:	9941                	andi	a0,a0,-16
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
80001ec2:	4802                	lw	a6,0(sp)
80001ec4:	4722                	lw	a4,8(sp)
80001ec6:	46b2                	lw	a3,12(sp)
	stack_ptr -= delta;
80001ec8:	40a989b3          	sub	s3,s3,a0
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
80001ecc:	d864                	sw	s1,116(s0)
	new_thread->stack_info.size = stack_buf_size;
80001ece:	07242c23          	sw	s2,120(s0)
	new_thread->stack_info.delta = delta;
80001ed2:	dc68                	sw	a0,124(s0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
80001ed4:	864e                	mv	a2,s3
80001ed6:	8522                	mv	a0,s0
80001ed8:	85a6                	mv	a1,s1
80001eda:	e50ff0ef          	jal	ra,8000152a <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
80001ede:	800037b7          	lui	a5,0x80003
80001ee2:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80001ee6:	479c                	lw	a5,8(a5)
	new_thread->init_data = NULL;
80001ee8:	06042423          	sw	zero,104(s0)
}
80001eec:	854e                	mv	a0,s3
	new_thread->resource_pool = _current->resource_pool;
80001eee:	0887a783          	lw	a5,136(a5)
80001ef2:	08f42423          	sw	a5,136(s0)
}
80001ef6:	50b2                	lw	ra,44(sp)
80001ef8:	5422                	lw	s0,40(sp)
80001efa:	5492                	lw	s1,36(sp)
80001efc:	5902                	lw	s2,32(sp)
80001efe:	49f2                	lw	s3,28(sp)
80001f00:	6145                	addi	sp,sp,48
80001f02:	8082                	ret

80001f04 <z_init_static_threads>:
{
80001f04:	7179                	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
80001f06:	800037b7          	lui	a5,0x80003
{
80001f0a:	d04a                	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
80001f0c:	80003937          	lui	s2,0x80003
{
80001f10:	d422                	sw	s0,40(sp)
80001f12:	d226                	sw	s1,36(sp)
80001f14:	d606                	sw	ra,44(sp)
80001f16:	ce4e                	sw	s3,28(sp)
80001f18:	cc52                	sw	s4,24(sp)
80001f1a:	ca56                	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
80001f1c:	ad878413          	addi	s0,a5,-1320 # 80002ad8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002ad9>
80001f20:	ad878493          	addi	s1,a5,-1320
80001f24:	ad890913          	addi	s2,s2,-1320 # 80002ad8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002ad9>
80001f28:	03246363          	bltu	s0,s2,80001f4e <z_init_static_threads+0x4a>
	k_sched_lock();
80001f2c:	29d1                	jal	80002400 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
80001f2e:	8426                	mv	s0,s1
		if (thread_data->init_delay != K_TICKS_FOREVER) {
80001f30:	59fd                	li	s3,-1
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
80001f32:	4a25                	li	s4,9

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
80001f34:	80002ab7          	lui	s5,0x80002
	_FOREACH_STATIC_THREAD(thread_data) {
80001f38:	03246f63          	bltu	s0,s2,80001f76 <z_init_static_threads+0x72>
}
80001f3c:	5422                	lw	s0,40(sp)
80001f3e:	50b2                	lw	ra,44(sp)
80001f40:	5492                	lw	s1,36(sp)
80001f42:	5902                	lw	s2,32(sp)
80001f44:	49f2                	lw	s3,28(sp)
80001f46:	4a62                	lw	s4,24(sp)
80001f48:	4ad2                	lw	s5,20(sp)
80001f4a:	6145                	addi	sp,sp,48
	k_sched_unlock();
80001f4c:	a9d1                	j	80002420 <k_sched_unlock>
		z_setup_new_thread(
80001f4e:	545c                	lw	a5,44(s0)
80001f50:	c23e                	sw	a5,4(sp)
80001f52:	501c                	lw	a5,32(s0)
80001f54:	c03e                	sw	a5,0(sp)
80001f56:	485c                	lw	a5,20(s0)
80001f58:	01c42883          	lw	a7,28(s0)
80001f5c:	01842803          	lw	a6,24(s0)
80001f60:	4818                	lw	a4,16(s0)
80001f62:	4454                	lw	a3,12(s0)
80001f64:	4410                	lw	a2,8(s0)
80001f66:	404c                	lw	a1,4(s0)
80001f68:	4008                	lw	a0,0(s0)
80001f6a:	3de5                	jal	80001e62 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
80001f6c:	401c                	lw	a5,0(s0)
80001f6e:	d7a0                	sw	s0,104(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
80001f70:	03040413          	addi	s0,s0,48
80001f74:	bf55                	j	80001f28 <z_init_static_threads+0x24>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
80001f76:	505c                	lw	a5,36(s0)
80001f78:	03378263          	beq	a5,s3,80001f9c <z_init_static_threads+0x98>
			schedule_new_thread(thread_data->init_thread,
80001f7c:	4004                	lw	s1,0(s0)
					    K_MSEC(thread_data->init_delay));
80001f7e:	0007d363          	bgez	a5,80001f84 <z_init_static_threads+0x80>
80001f82:	4781                	li	a5,0
80001f84:	00978513          	addi	a0,a5,9
80001f88:	41f7d713          	srai	a4,a5,0x1f
80001f8c:	00f535b3          	sltu	a1,a0,a5
80001f90:	95ba                	add	a1,a1,a4
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
80001f92:	01451863          	bne	a0,s4,80001fa2 <z_init_static_threads+0x9e>
80001f96:	e591                	bnez	a1,80001fa2 <z_init_static_threads+0x9e>
	z_sched_start(thread);
80001f98:	8526                	mv	a0,s1
80001f9a:	2911                	jal	800023ae <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
80001f9c:	03040413          	addi	s0,s0,48
80001fa0:	bf61                	j	80001f38 <z_init_static_threads+0x34>
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
80001fa2:	4629                	li	a2,10
80001fa4:	4681                	li	a3,0
80001fa6:	9befe0ef          	jal	ra,80000164 <__udivdi3>
80001faa:	862a                	mv	a2,a0
80001fac:	86ae                	mv	a3,a1
80001fae:	01848513          	addi	a0,s1,24
80001fb2:	24ca8593          	addi	a1,s5,588 # 8000224c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000224d>
80001fb6:	25b5                	jal	80002622 <z_add_timeout>
80001fb8:	b7d5                	j	80001f9c <z_init_static_threads+0x98>

80001fba <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
80001fba:	1141                	addi	sp,sp,-16
80001fbc:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80001fbe:	300477f3          	csrrci	a5,mstatus,8
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
80001fc2:	caaff0ef          	jal	ra,8000146c <arch_cpu_idle>
80001fc6:	bfe5                	j	80001fbe <idle+0x4>

80001fc8 <sys_dlist_remove>:
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
80001fc8:	4158                	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
80001fca:	411c                	lw	a5,0(a0)

	prev->next = next;
80001fcc:	c31c                	sw	a5,0(a4)
	next->prev = prev;
80001fce:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
80001fd0:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
80001fd4:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
80001fd8:	8082                	ret

80001fda <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
80001fda:	1141                	addi	sp,sp,-16
80001fdc:	c422                	sw	s0,8(sp)
80001fde:	c606                	sw	ra,12(sp)
80001fe0:	842a                	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
80001fe2:	37dd                	jal	80001fc8 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
80001fe4:	00d44783          	lbu	a5,13(s0)
	thread->base.pended_on = NULL;
80001fe8:	00042423          	sw	zero,8(s0)
80001fec:	9bf5                	andi	a5,a5,-3
80001fee:	00f406a3          	sb	a5,13(s0)
}
80001ff2:	40b2                	lw	ra,12(sp)
80001ff4:	4422                	lw	s0,8(sp)
80001ff6:	0141                	addi	sp,sp,16
80001ff8:	8082                	ret

80001ffa <z_reset_time_slice>:
{
80001ffa:	1141                	addi	sp,sp,-16
80001ffc:	c226                	sw	s1,4(sp)
	int ret = slice_ticks;
80001ffe:	800034b7          	lui	s1,0x80003
{
80002002:	c422                	sw	s0,8(sp)
	int ret = slice_ticks;
80002004:	0284a403          	lw	s0,40(s1) # 80003028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003029>
{
80002008:	c606                	sw	ra,12(sp)
	if (slice_time(curr) != 0) {
8000200a:	c005                	beqz	s0,8000202a <z_reset_time_slice+0x30>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
8000200c:	3665                	jal	80001bb4 <sys_clock_elapsed>
8000200e:	942a                	add	s0,s0,a0
80002010:	800037b7          	lui	a5,0x80003
80002014:	1687a423          	sw	s0,360(a5) # 80003168 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003169>
}
80002018:	4422                	lw	s0,8(sp)
		z_set_timeout_expiry(slice_time(curr), false);
8000201a:	0284a503          	lw	a0,40(s1)
}
8000201e:	40b2                	lw	ra,12(sp)
80002020:	4492                	lw	s1,4(sp)
		z_set_timeout_expiry(slice_time(curr), false);
80002022:	4581                	li	a1,0
}
80002024:	0141                	addi	sp,sp,16
		z_set_timeout_expiry(slice_time(curr), false);
80002026:	7500006f          	j	80002776 <z_set_timeout_expiry>
}
8000202a:	40b2                	lw	ra,12(sp)
8000202c:	4422                	lw	s0,8(sp)
8000202e:	4492                	lw	s1,4(sp)
80002030:	0141                	addi	sp,sp,16
80002032:	8082                	ret

80002034 <z_swap_irqlock>:
{
80002034:	1101                	addi	sp,sp,-32
80002036:	cc22                	sw	s0,24(sp)
	old_thread = _current;
80002038:	80003437          	lui	s0,0x80003
{
8000203c:	ca26                	sw	s1,20(sp)
8000203e:	c84a                	sw	s2,16(sp)
80002040:	ce06                	sw	ra,28(sp)
80002042:	c64e                	sw	s3,12(sp)
	old_thread = _current;
80002044:	15840913          	addi	s2,s0,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002048:	00892983          	lw	s3,8(s2)
{
8000204c:	84aa                	mv	s1,a0
	z_check_stack_sentinel();
8000204e:	33dd                	jal	80001e34 <z_check_stack_sentinel>
	old_thread->swap_retval = -EAGAIN;
80002050:	57d5                	li	a5,-11
80002052:	08f9a023          	sw	a5,128(s3)
80002056:	300477f3          	csrrci	a5,mstatus,8
	return _kernel.ready_q.cache;
8000205a:	01892903          	lw	s2,24(s2)
	if (new_thread != old_thread) {
8000205e:	15840413          	addi	s0,s0,344
80002062:	01298b63          	beq	s3,s2,80002078 <z_swap_irqlock+0x44>
		z_reset_time_slice(new_thread);
80002066:	854a                	mv	a0,s2
		_current_cpu->current = new_thread;
80002068:	01242423          	sw	s2,8(s0)
		z_reset_time_slice(new_thread);
8000206c:	3779                	jal	80001ffa <z_reset_time_slice>
8000206e:	08492503          	lw	a0,132(s2)
80002072:	85ce                	mv	a1,s3
80002074:	fccfe0ef          	jal	ra,80000840 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
80002078:	88a1                	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
8000207a:	3004a073          	csrs	mstatus,s1
	return _current->swap_retval;
8000207e:	441c                	lw	a5,8(s0)
}
80002080:	40f2                	lw	ra,28(sp)
80002082:	4462                	lw	s0,24(sp)
80002084:	0807a503          	lw	a0,128(a5)
80002088:	44d2                	lw	s1,20(sp)
8000208a:	4942                	lw	s2,16(sp)
8000208c:	49b2                	lw	s3,12(sp)
8000208e:	6105                	addi	sp,sp,32
80002090:	8082                	ret

80002092 <z_swap>:
{
80002092:	1101                	addi	sp,sp,-32
80002094:	cc22                	sw	s0,24(sp)
	old_thread = _current;
80002096:	80003437          	lui	s0,0x80003
8000209a:	15840793          	addi	a5,s0,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
{
8000209e:	ca26                	sw	s1,20(sp)
800020a0:	c84a                	sw	s2,16(sp)
800020a2:	ce06                	sw	ra,28(sp)
800020a4:	c64e                	sw	s3,12(sp)
	old_thread = _current;
800020a6:	0087a983          	lw	s3,8(a5)
{
800020aa:	892a                	mv	s2,a0
800020ac:	84ae                	mv	s1,a1
	z_check_stack_sentinel();
800020ae:	3359                	jal	80001e34 <z_check_stack_sentinel>
	old_thread->swap_retval = -EAGAIN;
800020b0:	57d5                	li	a5,-11
800020b2:	08f9a023          	sw	a5,128(s3)
	if (!is_spinlock || lock != &sched_spinlock) {
800020b6:	800037b7          	lui	a5,0x80003
800020ba:	17c78793          	addi	a5,a5,380 # 8000317c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000317d>
800020be:	15840413          	addi	s0,s0,344
800020c2:	00f90463          	beq	s2,a5,800020ca <z_swap+0x38>
	__asm__ volatile ("csrrc %0, mstatus, %1"
800020c6:	300477f3          	csrrci	a5,mstatus,8
800020ca:	01842903          	lw	s2,24(s0)
	if (new_thread != old_thread) {
800020ce:	01298b63          	beq	s3,s2,800020e4 <z_swap+0x52>
		z_reset_time_slice(new_thread);
800020d2:	854a                	mv	a0,s2
		_current_cpu->current = new_thread;
800020d4:	01242423          	sw	s2,8(s0)
		z_reset_time_slice(new_thread);
800020d8:	370d                	jal	80001ffa <z_reset_time_slice>
800020da:	08492503          	lw	a0,132(s2)
800020de:	85ce                	mv	a1,s3
800020e0:	f60fe0ef          	jal	ra,80000840 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
800020e4:	88a1                	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
800020e6:	3004a073          	csrs	mstatus,s1
	return _current->swap_retval;
800020ea:	441c                	lw	a5,8(s0)
}
800020ec:	40f2                	lw	ra,28(sp)
800020ee:	4462                	lw	s0,24(sp)
800020f0:	0807a503          	lw	a0,128(a5)
800020f4:	44d2                	lw	s1,20(sp)
800020f6:	4942                	lw	s2,16(sp)
800020f8:	49b2                	lw	s3,12(sp)
800020fa:	6105                	addi	sp,sp,32
800020fc:	8082                	ret

800020fe <update_cache>:
{
800020fe:	1141                	addi	sp,sp,-16
80002100:	c422                	sw	s0,8(sp)
	return list->head == list;
80002102:	80003437          	lui	s0,0x80003
80002106:	15840793          	addi	a5,s0,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
8000210a:	c606                	sw	ra,12(sp)
8000210c:	c226                	sw	s1,4(sp)
8000210e:	4fc4                	lw	s1,28(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80002110:	800037b7          	lui	a5,0x80003
80002114:	17478793          	addi	a5,a5,372 # 80003174 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003175>
80002118:	15840413          	addi	s0,s0,344
8000211c:	00f48363          	beq	s1,a5,80002122 <update_cache+0x24>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
80002120:	e091                	bnez	s1,80002124 <update_cache+0x26>
80002122:	4444                	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
80002124:	441c                	lw	a5,8(s0)
	if (preempt_ok != 0) {
80002126:	e919                	bnez	a0,8000213c <update_cache+0x3e>
	if (z_is_thread_prevented_from_running(_current)) {
80002128:	00d7c703          	lbu	a4,13(a5)
8000212c:	8b7d                	andi	a4,a4,31
8000212e:	e719                	bnez	a4,8000213c <update_cache+0x3e>
	if (is_preempt(_current) || is_metairq(thread)) {
80002130:	00e7d683          	lhu	a3,14(a5)
80002134:	07f00713          	li	a4,127
80002138:	00d76763          	bltu	a4,a3,80002146 <update_cache+0x48>
		if (thread != _current) {
8000213c:	00f48463          	beq	s1,a5,80002144 <update_cache+0x46>
			z_reset_time_slice(thread);
80002140:	8526                	mv	a0,s1
80002142:	3d65                	jal	80001ffa <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
80002144:	87a6                	mv	a5,s1
80002146:	cc1c                	sw	a5,24(s0)
}
80002148:	40b2                	lw	ra,12(sp)
8000214a:	4422                	lw	s0,8(sp)
8000214c:	4492                	lw	s1,4(sp)
8000214e:	0141                	addi	sp,sp,16
80002150:	8082                	ret

80002152 <move_thread_to_end_of_prio_q>:
{
80002152:	1141                	addi	sp,sp,-16
80002154:	c422                	sw	s0,8(sp)
80002156:	c606                	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
80002158:	00d54783          	lbu	a5,13(a0)
8000215c:	842a                	mv	s0,a0
	if (z_is_thread_queued(thread)) {
8000215e:	01879713          	slli	a4,a5,0x18
80002162:	8761                	srai	a4,a4,0x18
80002164:	00075763          	bgez	a4,80002172 <move_thread_to_end_of_prio_q+0x20>
	thread->base.thread_state &= ~_THREAD_QUEUED;
80002168:	07f7f793          	andi	a5,a5,127
8000216c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
80002170:	3da1                	jal	80001fc8 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
80002172:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
80002176:	80003737          	lui	a4,0x80003
8000217a:	800036b7          	lui	a3,0x80003
8000217e:	f807e793          	ori	a5,a5,-128
80002182:	00f406a3          	sb	a5,13(s0)
80002186:	15870793          	addi	a5,a4,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
8000218a:	4fdc                	lw	a5,28(a5)
8000218c:	17468693          	addi	a3,a3,372 # 80003174 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003175>
80002190:	15870713          	addi	a4,a4,344
	return sys_dlist_is_empty(list) ? NULL : list->head;
80002194:	00d79363          	bne	a5,a3,8000219a <move_thread_to_end_of_prio_q+0x48>
80002198:	4781                	li	a5,0
	return (node == list->tail) ? NULL : node->next;
8000219a:	5310                	lw	a2,32(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
8000219c:	e791                	bnez	a5,800021a8 <move_thread_to_end_of_prio_q+0x56>
	node->next = list;
8000219e:	c014                	sw	a3,0(s0)
	node->prev = tail;
800021a0:	c050                	sw	a2,4(s0)
	tail->next = node;
800021a2:	c200                	sw	s0,0(a2)
	list->tail = node;
800021a4:	d300                	sw	s0,32(a4)
}
800021a6:	a831                	j	800021c2 <move_thread_to_end_of_prio_q+0x70>
	int32_t b1 = thread_1->base.prio;
800021a8:	00e40583          	lb	a1,14(s0)
	int32_t b2 = thread_2->base.prio;
800021ac:	00e78503          	lb	a0,14(a5)
	if (b1 != b2) {
800021b0:	02a58163          	beq	a1,a0,800021d2 <move_thread_to_end_of_prio_q+0x80>
		if (z_sched_prio_cmp(thread, t) > 0) {
800021b4:	00a5df63          	bge	a1,a0,800021d2 <move_thread_to_end_of_prio_q+0x80>
	sys_dnode_t *const prev = successor->prev;
800021b8:	43d4                	lw	a3,4(a5)
	node->next = successor;
800021ba:	c01c                	sw	a5,0(s0)
	node->prev = prev;
800021bc:	c054                	sw	a3,4(s0)
	prev->next = node;
800021be:	c280                	sw	s0,0(a3)
	successor->prev = node;
800021c0:	c3c0                	sw	s0,4(a5)
	update_cache(thread == _current);
800021c2:	4708                	lw	a0,8(a4)
}
800021c4:	40b2                	lw	ra,12(sp)
	update_cache(thread == _current);
800021c6:	8d01                	sub	a0,a0,s0
}
800021c8:	4422                	lw	s0,8(sp)
	update_cache(thread == _current);
800021ca:	00153513          	seqz	a0,a0
}
800021ce:	0141                	addi	sp,sp,16
	update_cache(thread == _current);
800021d0:	b73d                	j	800020fe <update_cache>
	return (node == list->tail) ? NULL : node->next;
800021d2:	fcf606e3          	beq	a2,a5,8000219e <move_thread_to_end_of_prio_q+0x4c>
800021d6:	439c                	lw	a5,0(a5)
800021d8:	b7d1                	j	8000219c <move_thread_to_end_of_prio_q+0x4a>

800021da <ready_thread>:
800021da:	00d54703          	lbu	a4,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
800021de:	01871793          	slli	a5,a4,0x18
800021e2:	87e1                	srai	a5,a5,0x18
800021e4:	0607c363          	bltz	a5,8000224a <ready_thread+0x70>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
800021e8:	01f77793          	andi	a5,a4,31
800021ec:	efb9                	bnez	a5,8000224a <ready_thread+0x70>
	return node->next != NULL;
800021ee:	4d1c                	lw	a5,24(a0)
800021f0:	efa9                	bnez	a5,8000224a <ready_thread+0x70>
	thread->base.thread_state |= _THREAD_QUEUED;
800021f2:	f8076713          	ori	a4,a4,-128
800021f6:	00e506a3          	sb	a4,13(a0)
	return list->head == list;
800021fa:	80003737          	lui	a4,0x80003
800021fe:	15870693          	addi	a3,a4,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002202:	4ed0                	lw	a2,28(a3)
80002204:	800036b7          	lui	a3,0x80003
80002208:	17468693          	addi	a3,a3,372 # 80003174 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003175>
8000220c:	15870713          	addi	a4,a4,344
	return sys_dlist_is_empty(list) ? NULL : list->head;
80002210:	00d60363          	beq	a2,a3,80002216 <ready_thread+0x3c>
80002214:	87b2                	mv	a5,a2
	return (node == list->tail) ? NULL : node->next;
80002216:	5310                	lw	a2,32(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80002218:	e791                	bnez	a5,80002224 <ready_thread+0x4a>
	node->next = list;
8000221a:	c114                	sw	a3,0(a0)
	node->prev = tail;
8000221c:	c150                	sw	a2,4(a0)
	tail->next = node;
8000221e:	c208                	sw	a0,0(a2)
	list->tail = node;
80002220:	d308                	sw	a0,32(a4)
}
80002222:	a831                	j	8000223e <ready_thread+0x64>
	int32_t b1 = thread_1->base.prio;
80002224:	00e50583          	lb	a1,14(a0)
	int32_t b2 = thread_2->base.prio;
80002228:	00e78803          	lb	a6,14(a5)
	if (b1 != b2) {
8000222c:	01058b63          	beq	a1,a6,80002242 <ready_thread+0x68>
		if (z_sched_prio_cmp(thread, t) > 0) {
80002230:	0105d963          	bge	a1,a6,80002242 <ready_thread+0x68>
	sys_dnode_t *const prev = successor->prev;
80002234:	43d8                	lw	a4,4(a5)
	node->next = successor;
80002236:	c11c                	sw	a5,0(a0)
	node->prev = prev;
80002238:	c158                	sw	a4,4(a0)
	prev->next = node;
8000223a:	c308                	sw	a0,0(a4)
	successor->prev = node;
8000223c:	c3c8                	sw	a0,4(a5)
		update_cache(0);
8000223e:	4501                	li	a0,0
80002240:	bd7d                	j	800020fe <update_cache>
	return (node == list->tail) ? NULL : node->next;
80002242:	fcc78ce3          	beq	a5,a2,8000221a <ready_thread+0x40>
80002246:	439c                	lw	a5,0(a5)
80002248:	bfc1                	j	80002218 <ready_thread+0x3e>
}
8000224a:	8082                	ret

8000224c <z_thread_timeout>:
{
8000224c:	1101                	addi	sp,sp,-32
8000224e:	ce06                	sw	ra,28(sp)
80002250:	cc22                	sw	s0,24(sp)
80002252:	ca26                	sw	s1,20(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002254:	300474f3          	csrrci	s1,mstatus,8
		if (!killed) {
80002258:	ff554783          	lbu	a5,-11(a0)
8000225c:	0287f793          	andi	a5,a5,40
80002260:	ef99                	bnez	a5,8000227e <z_thread_timeout+0x32>
80002262:	842a                	mv	s0,a0
			if (thread->base.pended_on != NULL) {
80002264:	ff042783          	lw	a5,-16(s0)
	struct k_thread *thread = CONTAINER_OF(timeout,
80002268:	1521                	addi	a0,a0,-24
			if (thread->base.pended_on != NULL) {
8000226a:	c781                	beqz	a5,80002272 <z_thread_timeout+0x26>
				unpend_thread_no_timeout(thread);
8000226c:	c62a                	sw	a0,12(sp)
8000226e:	33b5                	jal	80001fda <unpend_thread_no_timeout>
80002270:	4532                	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
80002272:	ff544783          	lbu	a5,-11(s0)
80002276:	9bad                	andi	a5,a5,-21
80002278:	fef40aa3          	sb	a5,-11(s0)
			ready_thread(thread);
8000227c:	3fb9                	jal	800021da <ready_thread>
	__asm__ volatile ("csrs mstatus, %0"
8000227e:	88a1                	andi	s1,s1,8
80002280:	3004a073          	csrs	mstatus,s1
}
80002284:	40f2                	lw	ra,28(sp)
80002286:	4462                	lw	s0,24(sp)
80002288:	44d2                	lw	s1,20(sp)
8000228a:	6105                	addi	sp,sp,32
8000228c:	8082                	ret

8000228e <k_sched_time_slice_set>:
{
8000228e:	1141                	addi	sp,sp,-16
80002290:	c226                	sw	s1,4(sp)
80002292:	c606                	sw	ra,12(sp)
80002294:	c422                	sw	s0,8(sp)
80002296:	87aa                	mv	a5,a0
80002298:	84ae                	mv	s1,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
8000229a:	30047473          	csrrci	s0,mstatus,8
		t += off;
8000229e:	0525                	addi	a0,a0,9
800022a0:	00f535b3          	sltu	a1,a0,a5
		if (result32 && (t < BIT64(32))) {
800022a4:	02f56f63          	bltu	a0,a5,800022e2 <k_sched_time_slice_set+0x54>
			return ((uint32_t)t) / (from_hz / to_hz);
800022a8:	4729                	li	a4,10
800022aa:	02e55533          	divu	a0,a0,a4
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
800022ae:	02f04f63          	bgtz	a5,800022ec <k_sched_time_slice_set+0x5e>
		_current_cpu->slice_ticks = 0;
800022b2:	800037b7          	lui	a5,0x80003
800022b6:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
		slice_ticks = k_ms_to_ticks_ceil32(slice);
800022ba:	80003737          	lui	a4,0x80003
800022be:	02a72423          	sw	a0,40(a4) # 80003028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003029>
		z_reset_time_slice(_current);
800022c2:	4788                	lw	a0,8(a5)
		slice_max_prio = prio;
800022c4:	80003737          	lui	a4,0x80003
		_current_cpu->slice_ticks = 0;
800022c8:	0007a823          	sw	zero,16(a5)
		slice_max_prio = prio;
800022cc:	02972223          	sw	s1,36(a4) # 80003024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003025>
	__asm__ volatile ("csrs mstatus, %0"
800022d0:	8821                	andi	s0,s0,8
		z_reset_time_slice(_current);
800022d2:	3325                	jal	80001ffa <z_reset_time_slice>
800022d4:	30042073          	csrs	mstatus,s0
}
800022d8:	40b2                	lw	ra,12(sp)
800022da:	4422                	lw	s0,8(sp)
800022dc:	4492                	lw	s1,4(sp)
800022de:	0141                	addi	sp,sp,16
800022e0:	8082                	ret
			return t / ((uint64_t)from_hz / to_hz);
800022e2:	4629                	li	a2,10
800022e4:	4681                	li	a3,0
800022e6:	e7ffd0ef          	jal	ra,80000164 <__udivdi3>
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
800022ea:	b7e1                	j	800022b2 <k_sched_time_slice_set+0x24>
			slice_ticks = MAX(2, slice_ticks);
800022ec:	4789                	li	a5,2
800022ee:	fcf552e3          	bge	a0,a5,800022b2 <k_sched_time_slice_set+0x24>
800022f2:	4509                	li	a0,2
800022f4:	bf7d                	j	800022b2 <k_sched_time_slice_set+0x24>

800022f6 <z_time_slice>:
{
800022f6:	1101                	addi	sp,sp,-32
800022f8:	ce06                	sw	ra,28(sp)
800022fa:	cc22                	sw	s0,24(sp)
800022fc:	872a                	mv	a4,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800022fe:	30047473          	csrrci	s0,mstatus,8
	int ret = slice_ticks;
80002302:	80003637          	lui	a2,0x80003
	if (slice_time(_current) && sliceable(_current)) {
80002306:	02862603          	lw	a2,40(a2) # 80003028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003029>
8000230a:	800037b7          	lui	a5,0x80003
8000230e:	15878693          	addi	a3,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002312:	4688                	lw	a0,8(a3)
	return ret;
80002314:	15878793          	addi	a5,a5,344
	if (slice_time(_current) && sliceable(_current)) {
80002318:	ca31                	beqz	a2,8000236c <z_time_slice+0x76>
		&& !z_is_idle_thread_object(thread);
8000231a:	00e55583          	lhu	a1,14(a0)
8000231e:	07f00613          	li	a2,127
80002322:	04b66563          	bltu	a2,a1,8000236c <z_time_slice+0x76>
		&& !z_is_thread_prevented_from_running(thread)
80002326:	00d54603          	lbu	a2,13(a0)
8000232a:	8a7d                	andi	a2,a2,31
8000232c:	e221                	bnez	a2,8000236c <z_time_slice+0x76>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
8000232e:	80003637          	lui	a2,0x80003
80002332:	00e50583          	lb	a1,14(a0)
80002336:	02462603          	lw	a2,36(a2) # 80003024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003025>
8000233a:	02c5c963          	blt	a1,a2,8000236c <z_time_slice+0x76>
		&& !z_is_idle_thread_object(thread);
8000233e:	80003637          	lui	a2,0x80003
80002342:	03860613          	addi	a2,a2,56 # 80003038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003039>
80002346:	02c50363          	beq	a0,a2,8000236c <z_time_slice+0x76>
		if (ticks >= _current_cpu->slice_ticks) {
8000234a:	4a9c                	lw	a5,16(a3)
8000234c:	00f74d63          	blt	a4,a5,80002366 <z_time_slice+0x70>
		move_thread_to_end_of_prio_q(curr);
80002350:	c62a                	sw	a0,12(sp)
80002352:	3501                	jal	80002152 <move_thread_to_end_of_prio_q>
	z_reset_time_slice(curr);
80002354:	4532                	lw	a0,12(sp)
80002356:	3155                	jal	80001ffa <z_reset_time_slice>
	__asm__ volatile ("csrs mstatus, %0"
80002358:	8821                	andi	s0,s0,8
8000235a:	30042073          	csrs	mstatus,s0
}
8000235e:	40f2                	lw	ra,28(sp)
80002360:	4462                	lw	s0,24(sp)
80002362:	6105                	addi	sp,sp,32
80002364:	8082                	ret
			_current_cpu->slice_ticks -= ticks;
80002366:	8f99                	sub	a5,a5,a4
80002368:	ca9c                	sw	a5,16(a3)
8000236a:	b7fd                	j	80002358 <z_time_slice+0x62>
		_current_cpu->slice_ticks = 0;
8000236c:	0007a823          	sw	zero,16(a5)
80002370:	b7e5                	j	80002358 <z_time_slice+0x62>

80002372 <z_ready_thread>:
{
80002372:	1141                	addi	sp,sp,-16
80002374:	c606                	sw	ra,12(sp)
80002376:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002378:	30047473          	csrrci	s0,mstatus,8
			ready_thread(thread);
8000237c:	3db9                	jal	800021da <ready_thread>
	__asm__ volatile ("csrs mstatus, %0"
8000237e:	8821                	andi	s0,s0,8
80002380:	30042073          	csrs	mstatus,s0
}
80002384:	40b2                	lw	ra,12(sp)
80002386:	4422                	lw	s0,8(sp)
80002388:	0141                	addi	sp,sp,16
8000238a:	8082                	ret

8000238c <z_reschedule>:
			  : "memory");
}

static ALWAYS_INLINE bool arch_irq_unlocked(unsigned int key)
{
	return (key & MSTATUS_IEN) != 0;
8000238c:	0085f713          	andi	a4,a1,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
80002390:	cf01                	beqz	a4,800023a8 <z_reschedule+0x1c>
	bool ret = arch_curr_cpu()->nested != 0U;

	arch_irq_unlock(key);
	return ret;
#else
	return _kernel.cpus[0].nested != 0U;
80002392:	800037b7          	lui	a5,0x80003
80002396:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
8000239a:	4394                	lw	a3,0(a5)
8000239c:	e691                	bnez	a3,800023a8 <z_reschedule+0x1c>
	if (resched(key.key) && need_swap()) {
8000239e:	4f94                	lw	a3,24(a5)
800023a0:	479c                	lw	a5,8(a5)
800023a2:	00f68363          	beq	a3,a5,800023a8 <z_reschedule+0x1c>
		z_swap(lock, key);
800023a6:	b1f5                	j	80002092 <z_swap>
	__asm__ volatile ("csrs mstatus, %0"
800023a8:	30072073          	csrs	mstatus,a4
}
800023ac:	8082                	ret

800023ae <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
800023ae:	300475f3          	csrrci	a1,mstatus,8
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
800023b2:	00d54703          	lbu	a4,13(a0)
	if (z_has_thread_started(thread)) {
800023b6:	00477693          	andi	a3,a4,4
800023ba:	e689                	bnez	a3,800023c4 <z_sched_start+0x16>
	__asm__ volatile ("csrs mstatus, %0"
800023bc:	89a1                	andi	a1,a1,8
800023be:	3005a073          	csrs	mstatus,a1
		return;
800023c2:	8082                	ret
{
800023c4:	1101                	addi	sp,sp,-32
800023c6:	ce06                	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
800023c8:	9b6d                	andi	a4,a4,-5
800023ca:	00e506a3          	sb	a4,13(a0)
800023ce:	c62e                	sw	a1,12(sp)
	ready_thread(thread);
800023d0:	3529                	jal	800021da <ready_thread>
	z_reschedule(&sched_spinlock, key);
800023d2:	45b2                	lw	a1,12(sp)
}
800023d4:	40f2                	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
800023d6:	80003537          	lui	a0,0x80003
800023da:	17c50513          	addi	a0,a0,380 # 8000317c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000317d>
}
800023de:	6105                	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
800023e0:	b775                	j	8000238c <z_reschedule>

800023e2 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) != 0;
800023e2:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
800023e6:	c799                	beqz	a5,800023f4 <z_reschedule_irqlock+0x12>
800023e8:	80003737          	lui	a4,0x80003
800023ec:	15872703          	lw	a4,344(a4) # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
800023f0:	e311                	bnez	a4,800023f4 <z_reschedule_irqlock+0x12>
		z_swap_irqlock(key);
800023f2:	b189                	j	80002034 <z_swap_irqlock>
	__asm__ volatile ("csrs mstatus, %0"
800023f4:	3007a073          	csrs	mstatus,a5
}
800023f8:	8082                	ret

800023fa <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
800023fa:	30047573          	csrrci	a0,mstatus,8
	(void) z_reschedule_irqlock(arch_irq_lock());
800023fe:	b7d5                	j	800023e2 <z_reschedule_irqlock>

80002400 <k_sched_lock>:
80002400:	300477f3          	csrrci	a5,mstatus,8
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
80002404:	80003737          	lui	a4,0x80003
80002408:	15870713          	addi	a4,a4,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
8000240c:	4714                	lw	a3,8(a4)
8000240e:	00f6c703          	lbu	a4,15(a3)
80002412:	177d                	addi	a4,a4,-1
80002414:	00e687a3          	sb	a4,15(a3)
	__asm__ volatile ("csrs mstatus, %0"
80002418:	8ba1                	andi	a5,a5,8
8000241a:	3007a073          	csrs	mstatus,a5
}
8000241e:	8082                	ret

80002420 <k_sched_unlock>:
{
80002420:	1141                	addi	sp,sp,-16
80002422:	c606                	sw	ra,12(sp)
80002424:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002426:	30047473          	csrrci	s0,mstatus,8
		++_current->base.sched_locked;
8000242a:	800037b7          	lui	a5,0x80003
8000242e:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002432:	4798                	lw	a4,8(a5)
		update_cache(0);
80002434:	4501                	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
80002436:	8821                	andi	s0,s0,8
		++_current->base.sched_locked;
80002438:	00f74783          	lbu	a5,15(a4)
8000243c:	0785                	addi	a5,a5,1
8000243e:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
80002442:	3975                	jal	800020fe <update_cache>
80002444:	30042073          	csrs	mstatus,s0
}
80002448:	4422                	lw	s0,8(sp)
8000244a:	40b2                	lw	ra,12(sp)
8000244c:	0141                	addi	sp,sp,16
	z_reschedule_unlocked();
8000244e:	b775                	j	800023fa <z_reschedule_unlocked>

80002450 <z_swap_next_thread>:
	return _kernel.ready_q.cache;
80002450:	800037b7          	lui	a5,0x80003
}
80002454:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002458:	4f88                	lw	a0,24(a5)
8000245a:	8082                	ret

8000245c <z_get_next_switch_handle>:
{
8000245c:	1141                	addi	sp,sp,-16
8000245e:	c422                	sw	s0,8(sp)
80002460:	c606                	sw	ra,12(sp)
80002462:	842a                	mv	s0,a0
	z_check_stack_sentinel();
80002464:	9d1ff0ef          	jal	ra,80001e34 <z_check_stack_sentinel>
	z_sched_usage_switch(_kernel.ready_q.cache);
80002468:	800037b7          	lui	a5,0x80003
8000246c:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002470:	4f98                	lw	a4,24(a5)
	_current->switch_handle = interrupted;
80002472:	4794                	lw	a3,8(a5)
	_current_cpu->current = new_thread;
80002474:	c798                	sw	a4,8(a5)
	_current->switch_handle = interrupted;
80002476:	0886a223          	sw	s0,132(a3)
}
8000247a:	40b2                	lw	ra,12(sp)
8000247c:	4422                	lw	s0,8(sp)
8000247e:	08472503          	lw	a0,132(a4)
80002482:	0141                	addi	sp,sp,16
80002484:	8082                	ret

80002486 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
80002486:	800037b7          	lui	a5,0x80003
8000248a:	80003737          	lui	a4,0x80003
8000248e:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002492:	17470713          	addi	a4,a4,372 # 80003174 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003175>
80002496:	cfd8                	sw	a4,28(a5)
	list->tail = (sys_dnode_t *)list;
80002498:	d398                	sw	a4,32(a5)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
8000249a:	4581                	li	a1,0
8000249c:	4501                	li	a0,0
8000249e:	bbc5                	j	8000228e <k_sched_time_slice_set>

800024a0 <z_impl_z_current_get>:
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
800024a0:	800037b7          	lui	a5,0x80003

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
800024a4:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
800024a8:	4788                	lw	a0,8(a5)
800024aa:	8082                	ret

800024ac <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
800024ac:	1101                	addi	sp,sp,-32
800024ae:	ce06                	sw	ra,28(sp)
800024b0:	cc22                	sw	s0,24(sp)
800024b2:	ca26                	sw	s1,20(sp)
800024b4:	c84a                	sw	s2,16(sp)
800024b6:	c64e                	sw	s3,12(sp)
800024b8:	c452                	sw	s4,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
800024ba:	300479f3          	csrrci	s3,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
800024be:	00c54783          	lbu	a5,12(a0)
800024c2:	0089f913          	andi	s2,s3,8
800024c6:	8b85                	andi	a5,a5,1
800024c8:	cf99                	beqz	a5,800024e6 <z_thread_abort+0x3a>
	__asm__ volatile ("csrs mstatus, %0"
800024ca:	30092073          	csrs	mstatus,s2
	register unsigned long a0 __asm__ ("a0") = arg1;
800024ce:	4511                	li	a0,4
	register unsigned long t0 __asm__ ("t0") = call_id;
800024d0:	4281                	li	t0,0
	__asm__ volatile ("ecall"
800024d2:	00000073          	ecall
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
800024d6:	40f2                	lw	ra,28(sp)
800024d8:	4462                	lw	s0,24(sp)
800024da:	44d2                	lw	s1,20(sp)
800024dc:	4942                	lw	s2,16(sp)
800024de:	49b2                	lw	s3,12(sp)
800024e0:	4a22                	lw	s4,8(sp)
800024e2:	6105                	addi	sp,sp,32
800024e4:	8082                	ret
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
800024e6:	00d54783          	lbu	a5,13(a0)
800024ea:	842a                	mv	s0,a0
800024ec:	0087f713          	andi	a4,a5,8
800024f0:	c701                	beqz	a4,800024f8 <z_thread_abort+0x4c>
800024f2:	30092073          	csrs	mstatus,s2
800024f6:	b7c5                	j	800024d6 <z_thread_abort+0x2a>
		thread->base.thread_state &= ~_THREAD_ABORTING;
800024f8:	fdf7f713          	andi	a4,a5,-33
800024fc:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
80002500:	01871693          	slli	a3,a4,0x18
80002504:	86e1                	srai	a3,a3,0x18
80002506:	0406c363          	bltz	a3,8000254c <z_thread_abort+0xa0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
8000250a:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
8000250e:	441c                	lw	a5,8(s0)
80002510:	c399                	beqz	a5,80002516 <z_thread_abort+0x6a>
			unpend_thread_no_timeout(thread);
80002512:	8522                	mv	a0,s0
80002514:	34d9                	jal	80001fda <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
80002516:	01840513          	addi	a0,s0,24
8000251a:	2c25                	jal	80002752 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
8000251c:	06c40a13          	addi	s4,s0,108
	return list->head == list;
80002520:	5464                	lw	s1,108(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80002522:	01448363          	beq	s1,s4,80002528 <z_thread_abort+0x7c>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
80002526:	e89d                	bnez	s1,8000255c <z_thread_abort+0xb0>
		update_cache(1);
80002528:	4505                	li	a0,1
8000252a:	3ed1                	jal	800020fe <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
8000252c:	800037b7          	lui	a5,0x80003
80002530:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
80002534:	4798                	lw	a4,8(a5)
80002536:	fa871ee3          	bne	a4,s0,800024f2 <z_thread_abort+0x46>
8000253a:	439c                	lw	a5,0(a5)
8000253c:	fbdd                	bnez	a5,800024f2 <z_thread_abort+0x46>
		z_swap(&sched_spinlock, key);
8000253e:	80003537          	lui	a0,0x80003
80002542:	85ce                	mv	a1,s3
80002544:	17c50513          	addi	a0,a0,380 # 8000317c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000317d>
80002548:	36a9                	jal	80002092 <z_swap>
8000254a:	b765                	j	800024f2 <z_thread_abort+0x46>
	thread->base.thread_state &= ~_THREAD_QUEUED;
8000254c:	05f7f793          	andi	a5,a5,95
80002550:	0087e793          	ori	a5,a5,8
80002554:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
80002558:	3c85                	jal	80001fc8 <sys_dlist_remove>
}
8000255a:	bf55                	j	8000250e <z_thread_abort+0x62>
		unpend_thread_no_timeout(thread);
8000255c:	8526                	mv	a0,s1
8000255e:	3cb5                	jal	80001fda <unpend_thread_no_timeout>
80002560:	01848513          	addi	a0,s1,24
80002564:	22fd                	jal	80002752 <z_abort_timeout>
		ready_thread(thread);
80002566:	8526                	mv	a0,s1
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
80002568:	0804a023          	sw	zero,128(s1)
8000256c:	31bd                	jal	800021da <ready_thread>
8000256e:	bf4d                	j	80002520 <z_thread_abort+0x74>

80002570 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
80002570:	bf35                	j	800024ac <z_thread_abort>

80002572 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
80002572:	800037b7          	lui	a5,0x80003
80002576:	02c7a783          	lw	a5,44(a5) # 8000302c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000302d>
8000257a:	e399                	bnez	a5,80002580 <elapsed+0xe>
8000257c:	e38ff06f          	j	80001bb4 <sys_clock_elapsed>
}
80002580:	4501                	li	a0,0
80002582:	8082                	ret

80002584 <next_timeout>:

static int32_t next_timeout(void)
{
80002584:	1141                	addi	sp,sp,-16
	return list->head == list;
80002586:	800047b7          	lui	a5,0x80004
8000258a:	c606                	sw	ra,12(sp)
8000258c:	c422                	sw	s0,8(sp)
8000258e:	f9878793          	addi	a5,a5,-104 # 80003f98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f99>
80002592:	4380                	lw	s0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80002594:	02f41463          	bne	s0,a5,800025bc <next_timeout+0x38>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
80002598:	3fe9                	jal	80002572 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
8000259a:	80000537          	lui	a0,0x80000
8000259e:	fff54513          	not	a0,a0
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
800025a2:	800037b7          	lui	a5,0x80003
800025a6:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
800025aa:	4b9c                	lw	a5,16(a5)
800025ac:	c781                	beqz	a5,800025b4 <next_timeout+0x30>
800025ae:	00a7d363          	bge	a5,a0,800025b4 <next_timeout+0x30>
800025b2:	853e                	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
800025b4:	40b2                	lw	ra,12(sp)
800025b6:	4422                	lw	s0,8(sp)
800025b8:	0141                	addi	sp,sp,16
800025ba:	8082                	ret
	int32_t ticks_elapsed = elapsed();
800025bc:	3f5d                	jal	80002572 <elapsed>
	if ((to == NULL) ||
800025be:	dc71                	beqz	s0,8000259a <next_timeout+0x16>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
800025c0:	4818                	lw	a4,16(s0)
800025c2:	485c                	lw	a5,20(s0)
800025c4:	41f55693          	srai	a3,a0,0x1f
800025c8:	40a70533          	sub	a0,a4,a0
800025cc:	00a73733          	sltu	a4,a4,a0
800025d0:	8f95                	sub	a5,a5,a3
800025d2:	8f99                	sub	a5,a5,a4
	if ((to == NULL) ||
800025d4:	fcf043e3          	bgtz	a5,8000259a <next_timeout+0x16>
800025d8:	e399                	bnez	a5,800025de <next_timeout+0x5a>
800025da:	fc0540e3          	bltz	a0,8000259a <next_timeout+0x16>
		ret = MAX(0, to->dticks - ticks_elapsed);
800025de:	fc07d2e3          	bgez	a5,800025a2 <next_timeout+0x1e>
800025e2:	4501                	li	a0,0
800025e4:	bf7d                	j	800025a2 <next_timeout+0x1e>

800025e6 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
800025e6:	c50d                	beqz	a0,80002610 <remove_timeout+0x2a>
	return (node == list->tail) ? NULL : node->next;
800025e8:	800047b7          	lui	a5,0x80004
800025ec:	f9878793          	addi	a5,a5,-104 # 80003f98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f99>
800025f0:	43dc                	lw	a5,4(a5)
800025f2:	00f50f63          	beq	a0,a5,80002610 <remove_timeout+0x2a>
800025f6:	4118                	lw	a4,0(a0)
	if (next(t) != NULL) {
800025f8:	cf01                	beqz	a4,80002610 <remove_timeout+0x2a>
		next(t)->dticks += t->dticks;
800025fa:	4b1c                	lw	a5,16(a4)
800025fc:	4914                	lw	a3,16(a0)
800025fe:	494c                	lw	a1,20(a0)
80002600:	4b50                	lw	a2,20(a4)
80002602:	96be                	add	a3,a3,a5
80002604:	00f6b7b3          	sltu	a5,a3,a5
80002608:	962e                	add	a2,a2,a1
8000260a:	97b2                	add	a5,a5,a2
8000260c:	cb14                	sw	a3,16(a4)
8000260e:	cb5c                	sw	a5,20(a4)
	sys_dnode_t *const prev = node->prev;
80002610:	4158                	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
80002612:	411c                	lw	a5,0(a0)
	prev->next = next;
80002614:	c31c                	sw	a5,0(a4)
	next->prev = prev;
80002616:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
80002618:	00052023          	sw	zero,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	node->prev = NULL;
8000261c:	00052223          	sw	zero,4(a0)
}
80002620:	8082                	ret

80002622 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
80002622:	1101                	addi	sp,sp,-32
80002624:	cc22                	sw	s0,24(sp)
80002626:	c84a                	sw	s2,16(sp)
80002628:	c64e                	sw	s3,12(sp)
8000262a:	8736                	mv	a4,a3
8000262c:	89b6                	mv	s3,a3
8000262e:	ce06                	sw	ra,28(sp)
80002630:	ca26                	sw	s1,20(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
80002632:	56fd                	li	a3,-1
{
80002634:	842a                	mv	s0,a0
80002636:	8932                	mv	s2,a2
80002638:	87b2                	mv	a5,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
8000263a:	00d61463          	bne	a2,a3,80002642 <z_add_timeout+0x20>
8000263e:	0ec98763          	beq	s3,a2,8000272c <z_add_timeout+0x10a>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
80002642:	c40c                	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002644:	300474f3          	csrrci	s1,mstatus,8

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
80002648:	06075963          	bgez	a4,800026ba <z_add_timeout+0x98>
8000264c:	56fd                	li	a3,-1
8000264e:	00d71563          	bne	a4,a3,80002658 <z_add_timeout+0x36>
80002652:	5779                	li	a4,-2
80002654:	06f76363          	bltu	a4,a5,800026ba <z_add_timeout+0x98>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
80002658:	800037b7          	lui	a5,0x80003
8000265c:	0087a703          	lw	a4,8(a5) # 80003008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003009>
80002660:	00c7a783          	lw	a5,12(a5)
80002664:	56f9                	li	a3,-2
80002666:	40e68733          	sub	a4,a3,a4
8000266a:	00e6b6b3          	sltu	a3,a3,a4
8000266e:	fff7c793          	not	a5,a5
80002672:	8f95                	sub	a5,a5,a3
80002674:	41270533          	sub	a0,a4,s2
80002678:	00a73733          	sltu	a4,a4,a0
8000267c:	413787b3          	sub	a5,a5,s3
80002680:	8f99                	sub	a5,a5,a4

			to->dticks = MAX(1, ticks);
80002682:	00f04663          	bgtz	a5,8000268e <z_add_timeout+0x6c>
80002686:	e391                	bnez	a5,8000268a <z_add_timeout+0x68>
80002688:	e119                	bnez	a0,8000268e <z_add_timeout+0x6c>
8000268a:	4505                	li	a0,1
8000268c:	4781                	li	a5,0
	return list->head == list;
8000268e:	80004737          	lui	a4,0x80004
80002692:	c85c                	sw	a5,20(s0)
80002694:	f9870793          	addi	a5,a4,-104 # 80003f98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f99>
80002698:	439c                	lw	a5,0(a5)
8000269a:	c808                	sw	a0,16(s0)
8000269c:	f9870713          	addi	a4,a4,-104
	return sys_dlist_is_empty(list) ? NULL : list->head;
800026a0:	00e79363          	bne	a5,a4,800026a6 <z_add_timeout+0x84>
800026a4:	4781                	li	a5,0
	return (node == list->tail) ? NULL : node->next;
800026a6:	00472803          	lw	a6,4(a4)
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
800026aa:	e795                	bnez	a5,800026d6 <z_add_timeout+0xb4>
	node->next = list;
800026ac:	c018                	sw	a4,0(s0)
	node->prev = tail;
800026ae:	01042223          	sw	a6,4(s0)
	tail->next = node;
800026b2:	00882023          	sw	s0,0(a6) # 10000 <__rom_region_size+0xd000>
	list->tail = node;
800026b6:	c340                	sw	s0,4(a4)
}
800026b8:	a0b1                	j	80002704 <z_add_timeout+0xe2>
			to->dticks = timeout.ticks + 1 + elapsed();
800026ba:	3d65                	jal	80002572 <elapsed>
800026bc:	00190793          	addi	a5,s2,1
800026c0:	0127b933          	sltu	s2,a5,s2
800026c4:	41f55713          	srai	a4,a0,0x1f
800026c8:	994e                	add	s2,s2,s3
800026ca:	953e                	add	a0,a0,a5
800026cc:	00f537b3          	sltu	a5,a0,a5
800026d0:	993a                	add	s2,s2,a4
800026d2:	97ca                	add	a5,a5,s2
800026d4:	bf6d                	j	8000268e <z_add_timeout+0x6c>
			if (t->dticks > to->dticks) {
800026d6:	4bc8                	lw	a0,20(a5)
800026d8:	484c                	lw	a1,20(s0)
800026da:	4b94                	lw	a3,16(a5)
800026dc:	4810                	lw	a2,16(s0)
800026de:	00a5c663          	blt	a1,a0,800026ea <z_add_timeout+0xc8>
800026e2:	04b51c63          	bne	a0,a1,8000273a <z_add_timeout+0x118>
800026e6:	04d67a63          	bgeu	a2,a3,8000273a <z_add_timeout+0x118>
				t->dticks -= to->dticks;
800026ea:	40c68633          	sub	a2,a3,a2
800026ee:	00c6b6b3          	sltu	a3,a3,a2
800026f2:	8d0d                	sub	a0,a0,a1
800026f4:	8d15                	sub	a0,a0,a3
	sys_dnode_t *const prev = successor->prev;
800026f6:	43d4                	lw	a3,4(a5)
800026f8:	cb90                	sw	a2,16(a5)
800026fa:	cbc8                	sw	a0,20(a5)
	node->prev = prev;
800026fc:	c054                	sw	a3,4(s0)
	node->next = successor;
800026fe:	c01c                	sw	a5,0(s0)
	prev->next = node;
80002700:	c280                	sw	s0,0(a3)
	successor->prev = node;
80002702:	c3c0                	sw	s0,4(a5)
	return list->head == list;
80002704:	431c                	lw	a5,0(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80002706:	02e78063          	beq	a5,a4,80002726 <z_add_timeout+0x104>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
8000270a:	00f41e63          	bne	s0,a5,80002726 <z_add_timeout+0x104>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
8000270e:	3d9d                	jal	80002584 <next_timeout>

			if (next_time == 0 ||
80002710:	c901                	beqz	a0,80002720 <z_add_timeout+0xfe>
			    _current_cpu->slice_ticks != next_time) {
80002712:	800037b7          	lui	a5,0x80003
80002716:	15878793          	addi	a5,a5,344 # 80003158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003159>
			if (next_time == 0 ||
8000271a:	4b9c                	lw	a5,16(a5)
8000271c:	00a78563          	beq	a5,a0,80002726 <z_add_timeout+0x104>
				sys_clock_set_timeout(next_time, false);
80002720:	4581                	li	a1,0
80002722:	be2ff0ef          	jal	ra,80001b04 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
80002726:	88a1                	andi	s1,s1,8
80002728:	3004a073          	csrs	mstatus,s1
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
8000272c:	40f2                	lw	ra,28(sp)
8000272e:	4462                	lw	s0,24(sp)
80002730:	44d2                	lw	s1,20(sp)
80002732:	4942                	lw	s2,16(sp)
80002734:	49b2                	lw	s3,12(sp)
80002736:	6105                	addi	sp,sp,32
80002738:	8082                	ret
			to->dticks -= t->dticks;
8000273a:	40d606b3          	sub	a3,a2,a3
8000273e:	00d63633          	sltu	a2,a2,a3
80002742:	8d89                	sub	a1,a1,a0
80002744:	8d91                	sub	a1,a1,a2
80002746:	c814                	sw	a3,16(s0)
80002748:	c84c                	sw	a1,20(s0)
	return (node == list->tail) ? NULL : node->next;
8000274a:	f70781e3          	beq	a5,a6,800026ac <z_add_timeout+0x8a>
8000274e:	439c                	lw	a5,0(a5)
80002750:	bfa9                	j	800026aa <z_add_timeout+0x88>

80002752 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
80002752:	1141                	addi	sp,sp,-16
80002754:	c606                	sw	ra,12(sp)
80002756:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002758:	30047473          	csrrci	s0,mstatus,8
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
8000275c:	411c                	lw	a5,0(a0)
8000275e:	cb91                	beqz	a5,80002772 <z_abort_timeout+0x20>
			remove_timeout(to);
80002760:	3559                	jal	800025e6 <remove_timeout>
			ret = 0;
80002762:	4501                	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
80002764:	8821                	andi	s0,s0,8
80002766:	30042073          	csrs	mstatus,s0
		}
	}

	return ret;
}
8000276a:	40b2                	lw	ra,12(sp)
8000276c:	4422                	lw	s0,8(sp)
8000276e:	0141                	addi	sp,sp,16
80002770:	8082                	ret
	int ret = -EINVAL;
80002772:	5529                	li	a0,-22
80002774:	bfc5                	j	80002764 <z_abort_timeout+0x12>

80002776 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
80002776:	1101                	addi	sp,sp,-32
80002778:	cc22                	sw	s0,24(sp)
8000277a:	ce06                	sw	ra,28(sp)
8000277c:	ca26                	sw	s1,20(sp)
8000277e:	842a                	mv	s0,a0
80002780:	c62e                	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002782:	300474f3          	csrrci	s1,mstatus,8
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
80002786:	3bfd                	jal	80002584 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
80002788:	4785                	li	a5,1
8000278a:	00a7da63          	bge	a5,a0,8000279e <z_set_timeout_expiry+0x28>
8000278e:	00854863          	blt	a0,s0,8000279e <z_set_timeout_expiry+0x28>
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
80002792:	45b2                	lw	a1,12(sp)
80002794:	00a45363          	bge	s0,a0,8000279a <z_set_timeout_expiry+0x24>
80002798:	8522                	mv	a0,s0
8000279a:	b6aff0ef          	jal	ra,80001b04 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
8000279e:	88a1                	andi	s1,s1,8
800027a0:	3004a073          	csrs	mstatus,s1
		}
	}
}
800027a4:	40f2                	lw	ra,28(sp)
800027a6:	4462                	lw	s0,24(sp)
800027a8:	44d2                	lw	s1,20(sp)
800027aa:	6105                	addi	sp,sp,32
800027ac:	8082                	ret

800027ae <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
800027ae:	7179                	addi	sp,sp,-48
800027b0:	d422                	sw	s0,40(sp)
800027b2:	d606                	sw	ra,44(sp)
800027b4:	d226                	sw	s1,36(sp)
800027b6:	d04a                	sw	s2,32(sp)
800027b8:	ce4e                	sw	s3,28(sp)
800027ba:	cc52                	sw	s4,24(sp)
800027bc:	ca56                	sw	s5,20(sp)
800027be:	842a                	mv	s0,a0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
800027c0:	3e1d                	jal	800022f6 <z_time_slice>
	__asm__ volatile ("csrrc %0, mstatus, %1"
800027c2:	30047973          	csrrci	s2,mstatus,8
	return list->head == list;
800027c6:	80004a37          	lui	s4,0x80004
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
800027ca:	80003ab7          	lui	s5,0x80003
800027ce:	f98a0a13          	addi	s4,s4,-104 # 80003f98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003f99>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
800027d2:	800039b7          	lui	s3,0x80003
800027d6:	000a2503          	lw	a0,0(s4)
	announce_remaining = ticks;
800027da:	028aa623          	sw	s0,44(s5) # 8000302c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000302d>
		curr_tick += dt;
800027de:	0089a783          	lw	a5,8(s3) # 80003008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80003009>
800027e2:	00c9a583          	lw	a1,12(s3)
			  : "r" (key & MSTATUS_IEN)
800027e6:	00897913          	andi	s2,s2,8
800027ea:	41f45693          	srai	a3,s0,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
800027ee:	03450363          	beq	a0,s4,80002814 <sys_clock_announce+0x66>
	while (first() != NULL && first()->dticks <= announce_remaining) {
800027f2:	c10d                	beqz	a0,80002814 <sys_clock_announce+0x66>
800027f4:	4958                	lw	a4,20(a0)
800027f6:	4904                	lw	s1,16(a0)
800027f8:	00e6c663          	blt	a3,a4,80002804 <sys_clock_announce+0x56>
800027fc:	04d71663          	bne	a4,a3,80002848 <sys_clock_announce+0x9a>
80002800:	04947463          	bgeu	s0,s1,80002848 <sys_clock_announce+0x9a>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
80002804:	40848633          	sub	a2,s1,s0
80002808:	00c4b4b3          	sltu	s1,s1,a2
8000280c:	8f15                	sub	a4,a4,a3
8000280e:	8f05                	sub	a4,a4,s1
80002810:	c910                	sw	a2,16(a0)
80002812:	c958                	sw	a4,20(a0)
	}

	curr_tick += announce_remaining;
80002814:	97a2                	add	a5,a5,s0
80002816:	96ae                	add	a3,a3,a1
80002818:	0087b433          	sltu	s0,a5,s0
8000281c:	9436                	add	s0,s0,a3
8000281e:	00f9a423          	sw	a5,8(s3)
80002822:	0089a623          	sw	s0,12(s3)
	announce_remaining = 0;
80002826:	020aa623          	sw	zero,44(s5)

	sys_clock_set_timeout(next_timeout(), false);
8000282a:	3ba9                	jal	80002584 <next_timeout>
8000282c:	4581                	li	a1,0
8000282e:	ad6ff0ef          	jal	ra,80001b04 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
80002832:	30092073          	csrs	mstatus,s2

	k_spin_unlock(&timeout_lock, key);
}
80002836:	50b2                	lw	ra,44(sp)
80002838:	5422                	lw	s0,40(sp)
8000283a:	5492                	lw	s1,36(sp)
8000283c:	5902                	lw	s2,32(sp)
8000283e:	49f2                	lw	s3,28(sp)
80002840:	4a62                	lw	s4,24(sp)
80002842:	4ad2                	lw	s5,20(sp)
80002844:	6145                	addi	sp,sp,48
80002846:	8082                	ret
		curr_tick += dt;
80002848:	97a6                	add	a5,a5,s1
8000284a:	41f4d693          	srai	a3,s1,0x1f
8000284e:	0097b733          	sltu	a4,a5,s1
80002852:	96ae                	add	a3,a3,a1
80002854:	00f9a423          	sw	a5,8(s3)
		t->dticks = 0;
80002858:	4801                	li	a6,0
8000285a:	4781                	li	a5,0
		curr_tick += dt;
8000285c:	9736                	add	a4,a4,a3
		t->dticks = 0;
8000285e:	c91c                	sw	a5,16(a0)
80002860:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
80002864:	00e9a623          	sw	a4,12(s3)
		remove_timeout(t);
80002868:	c62a                	sw	a0,12(sp)
8000286a:	3bb5                	jal	800025e6 <remove_timeout>
8000286c:	30092073          	csrs	mstatus,s2
		t->fn(t);
80002870:	4532                	lw	a0,12(sp)
80002872:	451c                	lw	a5,8(a0)
80002874:	9782                	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
80002876:	30047973          	csrrci	s2,mstatus,8
		announce_remaining -= dt;
8000287a:	02caa403          	lw	s0,44(s5)
8000287e:	8c05                	sub	s0,s0,s1
80002880:	bf99                	j	800027d6 <sys_clock_announce+0x28>

80002882 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
80002882:	80003637          	lui	a2,0x80003
80002886:	800035b7          	lui	a1,0x80003
8000288a:	80003537          	lui	a0,0x80003
8000288e:	c0060613          	addi	a2,a2,-1024 # 80002c00 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002c01>
80002892:	d1858593          	addi	a1,a1,-744 # 80002d18 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002d19>
80002896:	d3850513          	addi	a0,a0,-712 # 80002d38 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002d39>
8000289a:	9e0fe06f          	j	80000a7a <printk>

8000289e <_OffsetAbsSyms>:
GEN_SOC_OFFSET_SYMS();
#endif

GEN_ABSOLUTE_SYM(__z_arch_esf_t_SIZEOF, sizeof(z_arch_esf_t));

GEN_ABS_SYM_END
8000289e:	8082                	ret
